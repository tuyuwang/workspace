---
layout: default
title: 线程
nav_order: 2
parent: Objective-C
grand_parent: 语言
---

## 什么是线程

- 基本概念
- 结构
- 作用
- 调用栈
![线程结构](../../../images/iOS/线程结构.png)

#### 基本概念
栈:
- 从数据结构的角度来理解，栈是一种描述先进后出的数据结构；
- 从进程的内存空间角度来理解，栈是一种特殊的内存段，用于存放局部变量、函数参数、返回值等；

栈是向下增长，高地址往低地址方法，堆是向上增长。
栈帧：每个进程都会有自己的栈空间，而进程中的各个函数也会维护自己本身的一个栈的区域，这个区域就是栈帧。

FP寄存器|frame pointer|保存栈底地址|R11|64位
SP寄存器|stack pointer|保存栈顶地址|R13|64
LR寄存器|link register|

栈帧：
- 函数的返回地址和参数
- 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量
- 函数调用的上下文

#### 线程的执行状态
考虑到一个线程被挂起时，后续继续执行需要恢复现场，所以在挂起时相关现场需要被保存起来，比如当前执行到哪条指令了。

那么就要有相关的结构体来为线程保存运行时的状态，如下:

~~~Objecive-C   
_STRUCT_MCONTEXT64
{
    _STRUCT_ARM_EXCEPTION_STATE64   __es;
    _STRUCT_ARM_THREAD_STATE64      __ss;
    _STRUCT_ARM_NEON_STATE64        __ns;
};


_STRUCT_ARM_THREAD_STATE64
{
    __uint64_t __x[29]; /* General purpose registers x0-x28 */
    __uint64_t __fp;    /* Frame pointer x29 */         //为栈基址寄存，用于保存栈底地址；
    __uint64_t __lr;    /* Link register x30 */         //连接寄存器
    __uint64_t __sp;    /* Stack pointer x31 */         //栈顶寄存器，用于保存栈顶地址
    __uint64_t __pc;    /* Program counter */           //程序计数器
    __uint32_t __cpsr;  /* Current program status register */   //当前程序状态寄存器
    __uint32_t __pad;   /* Same size for 32-bit or 64-bit clients */
};
~~~

FP就是栈基址，它指向函数的栈帧起始地址；SP则是函数的栈指针，它指向栈顶的位置

pc:
程序计数器是用于存放下一条指令所在单元的地址的地方。单片机及汇编语言中常称作PC（program counter）。 　　为了保证程序(在操作系统中理解为进程)能够连续地执行下去，CPU必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器。在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器（PC）的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址。由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1。 　　当程序转移时，转移指令执行的最终结果就是要改变PC的值，此PC值就是转去的地址，以此实现转移。有些机器中也称PC为指令指针IP（Instruction Pointer）。

简单点说，pc指示了CPU当前要读取指令的地址

lr:保存调用跳转指令 bl 指令的下一条指令的内存地址.
LR（Link Register），连接寄存器的英文缩写，在ARM体系结构中LR的特殊用途有两种：一是用来保存子程序返回地址；二是当异常发生时，LR中保存的值等于异常发生时PC的值减4（或者减2），因此在各种异常模式下可以根据LR的值返回到异常发生前的相应位置继续执行。
当通过BL或BLX指令调用子程序时，硬件自动将子程序返回地址保存在R14寄存器中。在子程序返回时，把LR的值复制到程序计数器PC即可实现子程序返回。如，可以使用MOV PC, LR或者BX LR来完成子程序返回。另外，也可以在在子程序入口处使用下面的指令将LR保存到栈中。

对于arm64系的CPU来说， 如果寄存器以x开头则表明的是一个64位的寄存器，如果以w开头则表明是一个32位的寄存器，在系统中没有提供16位和8位的寄存器供访问和使用。其中32位的寄存器是64位寄存器的低32位部分并不是独立存在的。

B是最简单的跳转指令。要注意的是，跳转指令的实际值不是绝对地址，而是相对地址——是相对当前PC值的一个偏移量，它的值由汇编器计算得出。BL很常用,它在跳转之前会在寄存器LR(R14)中保存PC的当前内容。BL的经典用法如下：
~~~
 bl NEXT       ; 跳转到NEXT 
    …… 
    NEXT 
    …… 
    mov pc, lr    ; 从子程序返回。
~~~

- [1](http://blog.chinaunix.net/uid-16459552-id-3364761.html)
- [2](https://www.veryarm.com/106579.html)
- [3](https://juejin.im/post/5cadeda55188251ad87b0eed)
- [4](https://www.jianshu.com/p/91c5dc0a8bb9)

简书: hank老师

## 堆栈回溯


