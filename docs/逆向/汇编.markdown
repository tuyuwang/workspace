---
layout: default
title: 汇编
nav_order: 2
parent: 逆向
---

[原视频](https://ke.qq.com/webcourse/314467/100373187#taid=2314879998676067&vid=5285890787890582010)


## 汇编语言

特点：
1. 可以直接访问、控制各种硬件设备，比如存储器、CPU等，能最大限度地发挥硬件的功能
2. 能够不受编译器的限制，对生成的二进制代码进行完全的控制
3. 目标代码简短，占用内存少，执行速度快
4. 汇编指令是机器指令的助记符，同机器指令--对应。每一种CPU都有自己的机器指令集/汇编指令集，所以汇编语言不具备可移植性。
5. 不区分大小写，比如mov和MOV是一样的

## 总线

1. 每一个CPU芯片都有许多管脚，这些管脚和总线相连，CPU通过总线跟外部器件进行交互。
2. 总线：一根根导线的集合。
3. 总线的分类
- 地址总线
- 数据总线
- 控制总线

地址总线：
- 它的宽度决定了CPU的寻址能力。
- 8086的地址总线宽度是20，所以寻址能力是1M(2^20)

一根线可以传0/1两种状态，所以可寻地址2，所以地址总线20根，寻址能力就是2^20
内存的最小单元是1个字节，8个bit，即内存单元是1个字节

数据总线：
- 它的宽度决定了CPU的单次数据传送量，也就是数据传送速度
- 8086的数据总线宽度是16，所以单次最大传递2个字节的数据

控制总线：
- 它的宽度决定了CPU对其他器件的控制能力，能有多少种控制


## 寄存器

1. x30寄存器

x30寄存器存放的是函数的返回地址，当ret指令执行时刻，会寻找x30寄存器保存的地址值。在函数嵌套调用的时候，需要将x30入栈

2. 函数的参数和返回值

ARM64下，函数的参数是存放在X0到X7这8个寄存器里面的，如果超过8个参数，就会入栈。函数的返回值是放在X0寄存器里面。

3. 通用寄存器

ARM64拥有31个64位的通用寄存器x0到x30，这些寄存器通常用来存放一般性的数据，称为通用寄存器(有时也有特定用途)

- x0-x28的低32位对应w0-w28
- 通常，CPU会先将内存中的数据存储到通用寄存器中，然后再对通用寄存器中的数据进行运算

4. pc寄存器

- 指令指针寄存器，它指示了CPU当前要读取指令的地址
- 在内存或者磁盘上，指令和数据没有任何区别，都是二进制
- CPU在工作的时候把所有的信息看作指令，有得信息看作数据，为同样的信息赋予了不同的意义
- CPU将pc指向的内存单元的内存看作指令
- 如果内存中的某段内容曾被CPU执行过，那么它所在的内存单元必然被pc指向过

5. sp寄存器

保存栈底的地址

6. fp寄存器

也称x29寄存器属于通用寄存器，但是某些时候利用它保存栈顶的地址。


ARM64里面，对栈的操作是16字节操作的


## 汇编指令

1. adrp

~~~
adrp x0. #1
add x0,x0,0xf28
~~~

这个adrp经常会和add指令同时出现.那么这种情况,一般是获取一个常量或者全局变量.

>adrp x0, 1

x0寄存器的值 = 0x1002e6000(当前PC寄存器的低12位清零) + 0x1000(1左移12位)。这个地址正好是PC当前的值.为什么低12位清零呢?因为内存是分页管理的,ARM64架构中.一页正好是4KB,也就是12根地址总线的寻址范围.

>add x0,x0,#0xf28

x0寄存器的值 = 0x1002e7000(刚才算出来的基值) + 0xf28(偏移地址)


2. bl

>bl xxx

将下一条指令的地址放入lr(x30)寄存器，然后转到标号处执行指令

- CPU从何处执行指令是由pc中的内容决定的，我们可以通过改变pc的内容来控制CPU执行了目标指令
- ARM64提供了一个mov指令(传送指令),可以用来修改大部分寄存器的值
- mov指令不能用于设置pc的值，ARM64没有提供这样的功能
- ARM64提供了另外的指令来修改pc的值，这些指令统称为转移指令，最简单的是bl指令

3. st

- stur指令：把寄存器的值(32位)存到一个内存的虚地址内间
- stp/str指令：把寄存器的值(128位/64位)存到一个内存的虚地址内间

store pair/store register

4. ld

- ldr指令：从虚拟地址取一个单个的32位值 ？？？
- ldp指令：从虚拟地址取一个单个128位值
- dlp指令：从虚拟地址取一个单个的64位值 ？？？

load register/load pair

> str x30, [sp,#-0x10]!

!:先执行数据存放，然后减sp

5. tbnz

>tbnz   w9, #0x0, 0x104d50dfc 

对比w9与0是否相等，相等就跳转到地址0x104d50dfc

6. ret

默认使用lr(x30)寄存器的值，通过底层指令提示CPU此处作为下条指令的地址

7. b
跳转指令，跳转叶子函数

8. cbz
compare b zero 比较（Compare），如果结果为零（Zero）就转移（只能跳到后面的指令）

9. cbnz
比较，如果结果非零（Non Zero）就转移（只能跳到后面的指令）

## 规律:基于Xcode调试

函数最终会被转为汇编

1. 在起始位置会进行申请栈空间，结束时进行栈平衡。
~~~
Example`__39-[svc getMeta:]_block_invoke:
//申请栈空间
0x1044442f4 <+12>:   sub    sp, sp, #0x200            ; =0x200 
//...
//栈平衡
0x104444a30 <+1864>: add    sp, sp, #0x200            ; =0x200 
~~~

2. 保护x29，x30，即栈底与返回地址
~~~
...
// 保存在栈空间中
0x1024b0d58 <+4>:    stp    x29, x30, [sp, #0x10]
...
// 将原始的值返回到x29,x30中
0x1024b134c <+1528>: ldp    x29, x30, [sp, #0x10]
...
~~~
由于函数存在嵌套调用函数的行为，所以会需要对栈底与返回地址进行保护，函数开始执行时将这两个值写入栈空间中，在将要退出该函数之前，还原寄存器值。避免因嵌套其他函数，导致x29，x30被修改。

3. 取全局参数/局部参数，保存入栈中

4. 声明局部变量

oc实现是:
~~~
NSString *testStr = @"testAbc"
~~~

汇编实现:
~~~
...
0x1026b8d84 <+48>:   adrp   x0, 3731
0x1026b8d88 <+52>:   add    x0, x0, #0x918            ; =0x918 
0x1026b8d8c <+56>:   bl     0x102e5d1cc               ; symbol stub for: objc_retain
0x1026b8d90 <+60>:   stur   x0, [x29, #-0x60]
...
~~~

adrp+add寻找字符串地址，放入x0中，使用register read x0可以输出testAbc。然后使用bl 调用retain进行retain操作。最后将值存入栈中，解放x0，并方便后面使用该字符串。

5. 函数调用

oc实现：
~~~
[NSFileManager defaultManager];
~~~

汇编:
~~~
0x1026b8da4 <+80>:   adrp   x8, 5170
0x1026b8da8 <+84>:   add    x8, x8, #0x868            ; =0x868 
0x1026b8dac <+88>:   ldr    x0, [x8]
0x1026b8db0 <+92>:   adrp   x8, 5090
0x1026b8db4 <+96>:   add    x8, x8, #0x418            ; =0x418 
0x1026b8db8 <+100>:  ldr    x1, [x8]
0x1026b8dbc <+104>:  bl     0x102e5d19c               ; symbol stub for: objc_msgSend
0x1026b8dc0 <+108>:  mov    x29, x29
0x1026b8dc4 <+112>:  bl     0x102e5d1f0               ; symbol stub for: objc_retainAutoreleasedReturnValue
~~~

adrp+add找出NSFileManager存入x8中，然后赋值给x0，同样的步骤找出defaultManager，赋值给x1。最后进行objc_msgSend进行调用。对应oc的消息转发原理，x0为self，x1为selector。

该方法得到的返回值，也就是[NSFileManager defaultManager]的实例对象存放在x0中。可以通过register read x0和po [NSFileManager defaultManager]对比地址，是一致的。

汇编中，返回值一般存放在x0中，函数调用x0一般为self，x1一般为selector

6. block 调用

~~~
HLLDriver_Example`__29-[SplashScreenVC viewDidLoad]_block_invoke at SplashScreenVC.m:46

HLLDriver_Example`__block_descriptor_48_e5_v8?0ls32l8r40l8 + 512
~~~

