---
layout: default
title: 汇编
nav_order: 2
parent: 逆向
---

[原视频](https://ke.qq.com/webcourse/314467/100373187#taid=2314879998676067&vid=5285890787890582010)


## 汇编语言

特点：
1. 可以直接访问、控制各种硬件设备，比如存储器、CPU等，能最大限度地发挥硬件的功能
2. 能够不受编译器的限制，对生成的二进制代码进行完全的控制
3. 目标代码简短，占用内存少，执行速度快
4. 汇编指令是机器指令的助记符，同机器指令--对应。每一种CPU都有自己的机器指令集/汇编指令集，所以汇编语言不具备可移植性。
5. 不区分大小写，比如mov和MOV是一样的

## 总线

1. 每一个CPU芯片都有许多管脚，这些管脚和总线相连，CPU通过总线跟外部器件进行交互。
2. 总线：一根根导线的集合。
3. 总线的分类
- 地址总线
- 数据总线
- 控制总线

地址总线：
- 它的宽度决定了CPU的寻址能力。
- 8086的地址总线宽度是20，所以寻址能力是1M(2^20)

一根线可以传0/1两种状态，所以可寻地址2，所以地址总线20根，寻址能力就是2^20
内存的最小单元是1个字节，8个bit，即内存单元是1个字节

数据总线：
- 它的宽度决定了CPU的单次数据传送量，也就是数据传送速度
- 8086的数据总线宽度是16，所以单次最大传递2个字节的数据

控制总线：
- 它的宽度决定了CPU对其他器件的控制能力，能有多少种控制


## 寄存器

1. x30寄存器

x30寄存器存放的是函数的返回地址，当ret指令执行时刻，会寻找x30寄存器保存的地址值。在函数嵌套调用的时候，需要将x30入栈

2. 函数的参数和返回值

ARM64下，函数的参数是存放在X0到X7这8个寄存器里面的，如果超过8个参数，就会入栈。函数的返回值是放在X0寄存器里面。

3. 通用寄存器

ARM64拥有31个64位的通用寄存器x0到x30，这些寄存器通常用来存放一般性的数据，称为通用寄存器(有时也有特定用途)

- x0-x28的低32位对应w0-w28
- 通常，CPU会先将内存中的数据存储到通用寄存器中，然后再对通用寄存器中的数据进行运算

4. pc寄存器

- 指令指针寄存器，它指示了CPU当前要读取指令的地址
- 在内存或者磁盘上，指令和数据没有任何区别，都是二进制
- CPU在工作的时候把所有的信息看作指令，有得信息看作数据，为同样的信息赋予了不同的意义
- CPU将pc指向的内存单元的内存看作指令
- 如果内存中的某段内容曾被CPU执行过，那么它所在的内存单元必然被pc指向过

5. sp寄存器

保存栈底的地址

6. fp寄存器

也称x29寄存器属于通用寄存器，但是某些时候利用它保存栈顶的地址。


ARM64里面，对栈的操作是16字节操作的


## 汇编指令

1. adrp

~~~
adrp x0. #1
add x0,x0,0xf28
~~~

这个adrp经常会和add指令同时出现.那么这种情况,一般是获取一个常量或者全局变量.

>adrp x0, 1

x0寄存器的值 = 0x1002e6000(当前PC寄存器的低12位清零) + 0x1000(1左移12位)。这个地址正好是PC当前的值.为什么低12位清零呢?因为内存是分页管理的,ARM64架构中.一页正好是4KB,也就是12根地址总线的寻址范围.

>add x0,x0,#0xf28

x0寄存器的值 = 0x1002e7000(刚才算出来的基值) + 0xf28(偏移地址)


2. bl

>bl xxx

将下一条指令的地址放入lr(x30)寄存器，然后转到标号处执行指令

- CPU从何处执行指令是由pc中的内容决定的，我们可以通过改变pc的内容来控制CPU执行了目标指令
- ARM64提供了一个mov指令(传送指令),可以用来修改大部分寄存器的值
- mov指令不能用于设置pc的值，ARM64没有提供这样的功能
- ARM64提供了另外的指令来修改pc的值，这些指令统称为转移指令，最简单的是bl指令

3. st

- stur指令：把寄存器的值(32位)存到一个内存的虚地址内间
- stp/str指令：把寄存器的值(128位/64位)存到一个内存的虚地址内间

store pair/store register

4. ld

- ldr指令：从虚拟地址取一个单个的32位值 ？？？
- ldp指令：从虚拟地址取一个单个128位值
- dlp指令：从虚拟地址取一个单个的64位值 ？？？

load register/load pair

> str x30, [sp,#-0x10]!

!:先执行数据存放，然后减sp

5. tbnz

>tbnz   w9, #0x0, 0x104d50dfc 

对比w9与0是否相等，相等就跳转到地址0x104d50dfc

#### ret

默认使用lr(x30)寄存器的值，通过底层指令提示CPU此处作为下条指令的地址
