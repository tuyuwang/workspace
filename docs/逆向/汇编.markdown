---
layout: default
title: 汇编
nav_order: 2
parent: 逆向
---

[原视频](https://ke.qq.com/webcourse/314467/100373187#taid=2314879998676067&vid=5285890787890582010)
[汇编基础](https://juejin.cn/post/6844903816362459144)

## 汇编语言

特点：
1. 可以直接访问、控制各种硬件设备，比如存储器、CPU等，能最大限度地发挥硬件的功能
2. 能够不受编译器的限制，对生成的二进制代码进行完全的控制
3. 目标代码简短，占用内存少，执行速度快
4. 汇编指令是机器指令的助记符，同机器指令--对应。每一种CPU都有自己的机器指令集/汇编指令集，所以汇编语言不具备可移植性。
5. 不区分大小写，比如mov和MOV是一样的

## 总线

1. 每一个CPU芯片都有许多管脚，这些管脚和总线相连，CPU通过总线跟外部器件进行交互。
2. 总线：一根根导线的集合。
3. 总线的分类
- 地址总线
- 数据总线
- 控制总线

地址总线：
- 它的宽度决定了CPU的寻址能力。
- 8086的地址总线宽度是20，所以寻址能力是1M(2^20)

一根线可以传0/1两种状态，所以可寻地址2，所以地址总线20根，寻址能力就是2^20
内存的最小单元是1个字节，8个bit，即内存单元是1个字节

数据总线：
- 它的宽度决定了CPU的单次数据传送量，也就是数据传送速度
- 8086的数据总线宽度是16，所以单次最大传递2个字节的数据

控制总线：
- 它的宽度决定了CPU对其他器件的控制能力，能有多少种控制


## 寄存器

1. lr

即x30寄存器

x30寄存器存放的是函数的返回地址，当ret指令执行时刻，会寻找x30寄存器保存的地址值。在函数嵌套调用的时候，需要将x30入栈

2. 函数的参数和返回值

ARM64下，函数的参数是存放在X0到X7这8个寄存器里面的，如果超过8个参数，就会入栈。函数的返回值是放在X0寄存器里面。如果方法返回值是一个较大的数据结构时，结果会存在 x8 执行的地址上。

3. 通用寄存器

ARM64拥有31个64位的通用寄存器x0到x30，这些寄存器通常用来存放一般性的数据，称为通用寄存器(有时也有特定用途)

- x0-x28的低32位对应w0-w28
- 通常，CPU会先将内存中的数据存储到通用寄存器中，然后再对通用寄存器中的数据进行运算
- 在寄存器中进行运算，参数在栈中缓存
- 函数的返回值通常情况下是放在x0寄存器
- ARM64下，函数的参数通常情况下是存放在x0到x7寄存器这8个寄存器里面的。超过8个，超出的参数会入栈


4. pc寄存器

- 指令指针寄存器，它指示了CPU当前要读取指令的地址
- 在内存或者磁盘上，指令和数据没有任何区别，都是二进制
- CPU在工作的时候把所有的信息看作指令，有得信息看作数据，为同样的信息赋予了不同的意义
- CPU将pc指向的内存单元的内存看作指令
- 如果内存中的某段内容曾被CPU执行过，那么它所在的内存单元必然被pc指向过

5. sp寄存器

栈顶寄存器，保存栈顶的地址

6. fp寄存器

也称x29寄存器属于通用寄存器，但是某些时候利用它保存栈底的地址。

7. 向量寄存器

也称浮点型寄存器，每个寄存器的大小是128位的。可以访问不同的位数（word是32位）
- Bn：一个Byte的大小，即8位
- Hn：half word，即16位
- Sn：sinle word, 即32位
- Dn：double word，即64位
- Qn：quard word，即128位

8. zr

即x31寄存器，zero register，xzr/wzr分别表示64/32位，其作用就是0，写进去代表丢弃结果，读出来是0

9. cpsr

即状态寄存器。cpsr寄存器(32位)是按位起作用的，每一位都有专门的含义，记录特定的信息

- CPSR的低8位（包括I、F、T和M[4:0]）称为控制位，程序无法修改，除非CPU运行于特权模式下，程序才能修改控制位
- N、Z、C、V均为条件码标志位；其内容可被算术或逻辑运算的结果所改变，并且可以决定某条指令是否被执行
- N（Negative）标志：CPSR的第31位是N，符号标志位，记录相关指令执行后其结果是否为负数，如果位负数，则N=1；如果是正数，则N=0；
- Z（Zero）标志：CPSR的第30位是Z，0标志位；记录相关指令执行后，其结果是否为0，如果为0，则Z=1.如果不为0，则Z=0
- V（Overflow）标志：CPSR的第28位是V，溢出标志位；在进行有符号数运算的时候，如果超过了机器所能标识的范围，称为溢出
- C（Carry）标志：CPSR的第29位是C，进位标志位；加法运算：当运算结果产生了进位时（无符号数溢出），C = 1，否则C = 0；减法运算（包括CMP），当运算时产生了借位时(无符号数溢出)，C = 0，否则C = 1

ARM64里面，对栈的操作是16字节操作的


## 汇编指令

1. adrp

~~~
adrp x0. #1
add x0,x0,0xf28
~~~

这个adrp经常会和add指令同时出现.那么这种情况,一般是获取一个常量或者全局变量.

>adrp x0, 1

x0寄存器的值 = 0x1002e6000(当前PC寄存器的低12位清零) + 0x1000(1左移12位)。这个地址正好是PC当前的值.为什么低12位清零呢?因为内存是分页管理的,ARM64架构中.一页正好是4KB,也就是12根地址总线的寻址范围.

>add x0,x0,#0xf28

x0寄存器的值 = 0x1002e7000(刚才算出来的基值) + 0xf28(偏移地址)


2. bl

>bl xxx

将下一条指令的地址放入lr(x30)寄存器，然后转到标号处执行指令

- CPU从何处执行指令是由pc中的内容决定的，我们可以通过改变pc的内容来控制CPU执行了目标指令
- ARM64提供了一个mov指令(传送指令),可以用来修改大部分寄存器的值
- mov指令不能用于设置pc的值，ARM64没有提供这样的功能
- ARM64提供了另外的指令来修改pc的值，这些指令统称为转移指令，最简单的是bl指令

3. st

- stur指令：把寄存器的值(32位)存到一个内存的虚地址内间
- stp/str指令：把寄存器的值(128位/64位)存到一个内存的虚地址内间

store pair/store register

4. ld

- ldr指令：从虚拟地址取一个单个的32位值 ？？？
- ldp指令：从虚拟地址取一个单个128位值
- dlp指令：从虚拟地址取一个单个的64位值 ？？？

load register/load pair

> str x30, [sp,#-0x10]!

!:先执行数据存放，然后减sp

5. tbnz

>tbnz   w9, #0x0, 0x104d50dfc 

对比w9与0是否相等，相等就跳转到地址0x104d50dfc

6. ret

默认使用lr(x30)寄存器的值，通过底层指令提示CPU此处作为下条指令的地址

7. b
跳转指令，跳转叶子函数

8. cbz
compare b zero 比较（Compare），如果结果为零（Zero）就转移（只能跳到后面的指令）

9. cbnz
比较，如果结果非零（Non Zero）就转移（只能跳到后面的指令）

10. mov
将某一寄存器的值复制到另一寄存器（只能用于寄存器与寄存器或者寄存器与常量之间传值，不能用于内存地址）

11. add
将某一寄存器的值和另一寄存器的值 相加 并将结果保存在另一寄存器中

12. sub
将某一寄存器的值和另一寄存器的值 相减 并将结果保存在另一寄存器中

13. mul
将某一寄存器的值和另一个寄存器的值 相乘 并将结果保存在另一寄存器中

14. sdiv
（有符号数，对应 udiv: 无符号数）将某一寄存器的值和另一个寄存器的值 相除 并将结果保存在另一寄存器中

15. and
将某一寄存器的值和另一寄存器的值 按位与 并将结果保存到另一寄存器中

16. orr
将某一寄存器的值和另一寄存器的值 按位或 并将结果保存到另一寄存器中

17. eor
将某一寄存器的值和另一寄存器的值 按位异或 并将结果保存到另一寄存器中

18. strb
(store register byte) 将寄存器中的值写入到内存中（只存储一个字节）
~~~
strb w8, [sp, #7]     ; 将寄存器 w8 中的低 1 字节的值保存到栈内存 [sp + 7] 处 
~~~

19. ldr
(load register) 将内存中的值读取到寄存器中
~~~
ldr x0, [x1]          ; 将寄存器 x1 的值作为地址，取该内存地址的值放入寄存器 x0 中 
ldr w8, [sp, #0x8]    ; 将栈内存 [sp + 0x8] 处的值读取到 w8 寄存器中 
ldr x0, [x1, #4]!     ; 将寄存器 x1 的值加上 4 作为内存地址, 取该内存地址的值放入寄存器 x0 中, 然后将寄存器 x1 的值加上 4 放入寄存器 x1 中 
ldr x0, [x1], #4      ; 将寄存器 x1 的值作为内存地址，取内该存地址的值放入寄存器 x0 中, 再将寄存器 x1 的值加上 4 放入寄存器 x1 中 
ldr x0, [x1, x2]      ; 将寄存器 x1 和寄存器 x2 的值相加作为地址，取该内存地址的值放入寄存器 x0 中 
~~~

20. ldsb
(load register byte) 将内存中的值（只读取一个字节）读取到寄存器中
~~~
ldrsb	w8, [sp, #7]    ; 将栈内存 [sp + 7] 出的 低 1 字节的值读取到寄存器 w8 中
~~~

21. ldur
同 ldr 将内存中的值读取到寄存器中（一般用于 负 地址运算中）
~~~
ldur w8, [x29, #-0x4]     ; 将栈内存 [x29 - 0x04] 处的值读取到 w8 寄存器中
~~~

22. stp
入栈指令（str 的变种指令，可以同时操作两个寄存器）
~~~
stp x29, x30, [sp, #0x10] 	; 将 x29, x30 的值存入 sp 偏移 16 个字节的位置 
~~~

23. ldp
出栈指令（ldr 的变种指令，可以同时操作两个寄存器）
~~~
ldp x29, x30, [sp, #0x10] 	; 将 sp 偏移 16 个字节的值取出来，存入寄存器 x29 和寄存器 x30 
~~~

24. scvtf
(Signed Convert To Float)带符号 定点数 转换为 浮点数，如：
~~~
scvtf	d1, w0      ; 将寄存器 w0 的值(顶点数，转化成 浮点数) 保存到 向量寄存器/浮点寄存器 d1 中
~~~

25. fcvtzs
(Float Convert To Zero Signed)浮点数 转化为 定点数 （舍入为0），如：
~~~
fcvtzs w0, s0	    ; 将向量寄存器 s0 的值(浮点数，转换成 定点数)保存到寄存器 w0 中
~~~

25. cmp
比较指令，相当于 subs，影响程序状态寄存器 CPSR

26. cset
比较指令，满足条件，则并置 1，否则置 0 ，如：
~~~
cmp w8, #2        ; 将寄存器 w8 的值和常量 2 进行比较
cset w8, gt       ; 如果是大于(grater than)，则将寄存器 w8 的值设置为 1，否则设置为 0
~~~

27. brk
可以理解为跳转指令特殊的一种

28. LSL： 逻辑左移

29. LSR： 逻辑右移

30. ASR： 算术右移

31. ROR： 循环右移

32. b
（branch）跳转到某地址（无返回）, 不会改变 lr (x30) 寄存器的值；一般是本方法内的跳转，如 while 循环，if else 等 ，如：
~~~
b LBB0_1      ; 直接跳转到标签 ‘LLB0_1’ 处开始执行
~~~

33. bl
跳转到某地址（有返回），先将下一指令地址（即函数返回地址）保存到寄存器 lr (x30)中，再进行跳转 ；一般用于不同方法直接的调用 ，如：
~~~
bl 0x100cfa754	; 先将下一指令地址（‘0x100cfa754’ 函数调用后的返回地址）保存到寄存器 ‘lr’ 中，然后再调用 ‘0x100cfa754’ 函数
~~~

34. blr
跳转到 某寄存器 (的值)指向的地址（有返回），先将下一指令地址（即函数返回地址）保存到寄存器 lr (x30)中，再进行跳转 ；如：
~~~
blr x20       ; 先将下一指令地址（‘x20’指向的函数调用后的返回地址）保存到寄存器 ‘lr’ 中，然后再调用 ‘x20’ 指向的函数
~~~

35. br
跳转到某寄存器(的值)指向的地址（无返回）, 不会改变 lr (x30) 寄存器的值。


## 规律:基于Xcode调试

对栈的 分配/释放 操作只会对栈指针做加减法, 而不会对栈内存中的内容做任何修改(也不会把释放的栈空间设置为 0)。

函数最终会被转为汇编,每个函数的调用，都会有入栈和出栈的操作

1. 在起始位置会进行申请栈空间，结束时进行栈平衡。
~~~
Example`__39-[svc getMeta:]_block_invoke:
//申请栈空间
0x1044442f4 <+12>:   sub    sp, sp, #0x200            ; =0x200 
//...
//栈平衡
0x104444a30 <+1864>: add    sp, sp, #0x200            ; =0x200 
~~~

2. 保护x29，x30，即栈底与返回地址
~~~
...
// 保存在栈空间中
0x1024b0d58 <+4>:    stp    x29, x30, [sp, #0x10]
...
// 将原始的值返回到x29,x30中
0x1024b134c <+1528>: ldp    x29, x30, [sp, #0x10]
...
~~~
由于函数存在嵌套调用函数的行为，所以会需要对栈底与返回地址进行保护，函数开始执行时将这两个值写入栈空间中，在将要退出该函数之前，还原寄存器值。避免因嵌套其他函数，导致x29，x30被修改。

3. 取全局参数/局部参数，保存入栈中

4. 声明局部变量

oc实现是:
~~~
NSString *testStr = @"testAbc"
~~~

汇编实现:
~~~
...
0x1026b8d84 <+48>:   adrp   x0, 3731
0x1026b8d88 <+52>:   add    x0, x0, #0x918            ; =0x918 
0x1026b8d8c <+56>:   bl     0x102e5d1cc               ; symbol stub for: objc_retain
0x1026b8d90 <+60>:   stur   x0, [x29, #-0x60]
...
~~~

adrp+add寻找字符串地址，放入x0中，使用register read x0可以输出testAbc。然后使用bl 调用retain进行retain操作。最后将值存入栈中，解放x0，并方便后面使用该字符串。

5. 函数调用

oc实现：
~~~
[NSFileManager defaultManager];
~~~

汇编:
~~~
0x1026b8da4 <+80>:   adrp   x8, 5170
0x1026b8da8 <+84>:   add    x8, x8, #0x868            ; =0x868 
0x1026b8dac <+88>:   ldr    x0, [x8]
0x1026b8db0 <+92>:   adrp   x8, 5090
0x1026b8db4 <+96>:   add    x8, x8, #0x418            ; =0x418 
0x1026b8db8 <+100>:  ldr    x1, [x8]
0x1026b8dbc <+104>:  bl     0x102e5d19c               ; symbol stub for: objc_msgSend
0x1026b8dc0 <+108>:  mov    x29, x29
0x1026b8dc4 <+112>:  bl     0x102e5d1f0               ; symbol stub for: objc_retainAutoreleasedReturnValue
~~~

adrp+add找出NSFileManager存入x8中，然后赋值给x0，同样的步骤找出defaultManager，赋值给x1。最后进行objc_msgSend进行调用。对应oc的消息转发原理，x0为self，x1为selector。

该方法得到的返回值，也就是[NSFileManager defaultManager]的实例对象存放在x0中。可以通过register read x0和po [NSFileManager defaultManager]对比地址，是一致的。

汇编中，返回值一般存放在x0中，函数调用x0一般为self，x1一般为selector

6. block 调用

~~~
HLLDriver_Example`__29-[SplashScreenVC viewDidLoad]_block_invoke at SplashScreenVC.m:46

HLLDriver_Example`__block_descriptor_48_e5_v8?0ls32l8r40l8 + 512
~~~

## 规律：Xocde静态汇编

Product——>Perform Action——>Assemble PushAndPop.c

~~~
sub	sp, sp, #32             ; 更新栈顶寄存器的值，（可以看出：申请 32 字节占空间作为新用）
stp	x29, x30, [sp, #16]     ; 保存调用该函数前的栈顶寄存器的值和该函数结束返回后下一将执行指令地址值
add	x29, sp, #16            ; 更新栈底寄存器的值，(可以看出：还剩余 16 字节空间给该函数用)
adrp     x0, l_.str@PAGE        ; 获取 ‘l_.str’ 标签所在的页的地址 
add x0, x0, l_.str@PAGEOFF	; 获取 ‘l_.str’ 标签对应页地址的偏移
bl	_printf	                ; 调用 ‘printf’ 函数进行打印
stur	w0, [x29, #-4]          ; 将 w0 寄存器的值('bl' 函数调用的返回值)保存到 [x29 - 4] 的内存地址中
ldp	x29, x30, [sp, #16]     ; 恢复调用该函数之前栈底寄存器的值
add	sp, sp, #32             ; 恢复调用该函数之前栈顶寄存器的值
ret								
~~~
