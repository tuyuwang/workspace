---
layout: default
title: 基础知识
nav_order: 1
parent: interview
---

## 基础知识

1、@property中的属性关键字
- atomic/nonatomic
- readwrite/readonly
- assign/weak/unsafe_unretained/retain/copy/strong
- getter=<\name>/setter=<\name>

2、copy与mutablecopy
- 对不可变的对象、容器类、非容器类的copy操作都是指针的拷贝。mutableCopy是内容拷贝
- 对可变的对象、容器类、非容器类copy操作都是内容的拷贝。mutableCopy是内容拷贝
- copy生成的是不可变对象
- mutableCopy生成的是可变对象

3、runtime消息机制:

先在缓存里面找，然后在自身类搜索方法列表，再逐步搜索父类，最终到NSObject。找到就执行，否则进入转发机制。

首先，通过+ (BOOL)resolveInstanceMethod:(SEL)sel、+ (BOOL)resolveClassMethod:(SEL)self方法动态添加,如果实现了动态添加，则返回YES，否则不管返回YES或者NO都执行下一步。

~~~

@interface Test: NSObject

@end

@implementation Test

- (void)test:(NSString *)str isRight:(BOOL)right
{
    if (right) {
        NSLog(@"%@", str);
    } else {
        NSLog(@"false");
    }
    
}
@end

+ (BOOL)resolveInstanceMethod:(SEL)sel
{
//    if (sel == @selector(test)) {
//        class_addMethod([self class], sel, (IMP)testViewController, "v@:");
//        return YES;
//    }
    return [super resolveInstanceMethod:sel];
}

void testViewController(id obj, SEL _cmd)
{
    NSLog(@"12334");
}


~~~

快速转发消息: 只能转发给一个对象。 - (id)forwardingTargetForSelector:(SEL)aSelector 返回其他可接受消息的对象。如果返回nil，直接进入下一步完整转发; 如果返回self, 无限循环。

~~~
- (id)forwardingTargetForSelector:(SEL)aSelector
{
    if (aSelector == @selector(test:isRight:)) {
         // return [Test new];
        return nil;
    }
    return [super forwardingTargetForSelector:aSelector];
}
~~~


完整消息转发: 可以转发给多个对象。 

~~~
- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
{
    if (aSelector == @selector(test:isRight:)) {
            //方法签名: v：返回值类型(void)、@：方法类型(实例方法／#：类方法)、: :selector(方法选择器)、@：对象参数、B：bool参数
            return [NSMethodSignature signatureWithObjCTypes:"v@:@B"];
        }
    return [super methodSignatureForSelector:aSelector];
}

- (void)forwardInvocation:(NSInvocation *)anInvocation
{
    SEL sel = anInvocation.selector;
        NSString *str;
        BOOL right;
        char *charStr;
        id target;

    Test *test = [Test new];
    if ([test respondsToSelector:sel]) {
        
        //获取参数
        //为什么参数位置从2开始，因为0：方法调用对象(首次调用方法的对象) 1: char(test:isRight) 参数...
        
        [anInvocation getArgument:&target atIndex:0];
        [anInvocation getArgument:&charStr atIndex:1];
        [anInvocation getArgument:&str atIndex:2];
        [anInvocation getArgument:&right atIndex:3];
        
        NSLog(@"%@", target);
        NSLog(@"%s", charStr);
        
        if (right) {
            NSLog(@"1223%@", str);
        }
        
        //可以篡改消息
        str = @"被篡改了";
        [anInvocation setArgument:&str atIndex:2];
        
        [anInvocation invokeWithTarget:test];

    } else {
        [self doesNotRecognizeSelector:sel];
    }
}

~~~

4、weak实现原理

runtime会维护一个weak的哈希表，以weak指向的对象的内存地址为键，weak指针的地址所组成的数组为值。当对象销毁时，遍历weak指针数组将指针分别置空。

5、向nil发送消息

OC发送消息时，会通过objc_msgSend进行实现，在这个过程中，会判断self是否为nil，当为nil的时候，会直接返回,不会造成crash。

6、如何判断上传和下载文件操作成功

用MD5验证数据完整性.上传时在请求body中添加该数据的MD5值，传输完毕后服务器校验

7、加密

- RSA(非对称加密): 使用一对非对称的公钥和私钥进行加密，解密

- AES(对称加密): 加密、解密用同一个密钥

- RSA加签: 用私钥在客户端加签，然后公钥在服务器用公钥验签。验证消息完整性。

8、self与super

self是关键字，代表当前方法的调用者

super是编译器指令

执行[super Class]时，编译器会先构造一个_rw_objc_super的结构体，然后在superClass方法列表中找方法，找到之后由object调用。
所以当你用[self Class]和[super Class]打印类的时候，打印的都是同一个类，因为他们只是查找方法的位置不同，但是调用方法的类/对象是一样的.

9、runloop

~~~
kCFRunLoopEntry = (1UL << 0),
kCFRunLoopBeforeTimers = (1UL << 1),
kCFRunLoopBeforeSources = (1UL << 2),
kCFRunLoopBeforeWaiting = (1UL << 5),
kCFRunLoopAfterWaiting = (1UL << 6),
kCFRunLoopExit = (1UL << 7),
~~~

10、字典的底层实现原理

哈希表就是把Key通过一个固定的算法函数即所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。

优点：不论哈希表中有多少数据，查找、插入、删除只需要接近常量的时间O(1)的时间级。哈希表的运算得非常快，在计算机程序中，如果需要在一秒钟内查找上千条记录通常使用哈希表，哈希表的速度明显比树快，树的操作通常要O(n)的时间级

缺点：它是基于数组的，数组创建后难于扩展，某些哈希表被基本填满时，性能下降得非常严重，所以程序员必须要清楚表中将要存储多少数据（或者准备好定期地把数据转移到更大的哈希表中，这是一个费时的过程）

散列法：元素特征变为数组下标的方法。

常用的散列法：
- 除法散列法： index = value % 16
- 平方散列法： 乘法运算要比除法来得省时，index = (value * value) >> 28 (右移，除以2^28. 记法：左移变大，是乘。右移变小，是除) 如果数值分配比较均匀的话这种方法能得到不错的结果，但我上面画的那个图的各个元素的值算出来的index都是0——非常失败。也许你还有个问题，value如果很大，value * value不会溢出吗？答案是会的，但我们这个乘法不关心溢出，因为我们根本不是为了获取相乘结果，而是为了获取index。
- 斐波那契散列法：
平方散列法的缺点是显而易见的，所以我们能不能找出一个理想的乘数，而不是拿value本身当作乘数呢？答案是肯定的。
1，对于16位整数而言，这个乘数是40503 
2，对于32位整数而言，这个乘数是2654435769 
3，对于64位整数而言，这个乘数是11400714819323198485
这几个“理想乘数”是如何得出来的呢？这跟一个法则有关，叫黄金分割法则，而描述黄金分割法则的最经典表达式无疑就是著名的斐波那契数列，即如此形式的序列：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233,377, 610， 987, 1597, 2584, 4181, 6765, 10946，…。另外，斐波那契数列的值和太阳系八大行星的轨道半径的比例出奇吻合。
 对我们常见的32位整数而言，公式： 
    index = (value * 2654435769) >> 28

当出现哈希碰撞时，通常两种方式解决：
- 链表法
- 开放寻址法

链表法：每个hash计算出的下标对应了一条值链表

开放寻址法： 通过寻址算法查找槽位
- 线性探查：h(k, i) = (h‘(k) + 1) mode n，i = 0, 1, ...，m-1
- 二次探查：采用如下列式的散列函数：h(k, i) = (h‘(k) + c1i + c2i^2) mod m
- 双重散列：双重散列是用于开放寻址法的最好方法之一，因为它所产生的排列具有随机选择排列的这么多特性。双重散列采用以下形式的散列函数：h(k, i) = (h1(k) + ih2(k)) mod m

哈希表还有一个重要的属性： 负载因子，它用来衡量哈希表的空/满程度，一定程度上也可以体现查询的效率，计算公式为：
负载因子 = 总键值对数/箱子个数

负载因子越大，意味着哈希表越满，越容易导致冲突，性能也就越低。因此，一般来说，负载因子大于某个常数（可能是1，或者0.75）时，哈希表将自动扩容。

哈希表在自动扩容时，一般会创建两倍于原来个数的箱子，因此即使 key 的哈希值不变，对箱子个数取余的结果也会发生改变，因此所有键值对的存放位置都有可能发生改变，这个过程也称为重哈希(rehash)。

哈希表的扩容并不总是能够有效解决负载因子过大的问题。假设所有 key 的哈希值都一样，那么即使扩容以后他们的位置也不会变化。虽然负载因子会降低，但实际存储在每个箱子中的链表长度并不发生改变，因此也就不能提高哈希表的查询性能。

11、Tagged Pointer 标记指针
为了改进从 32位CPU 迁移到 64位CPU 的内存浪费和效率问题，在 64位CPU 环境下，引入了 Tagged Pointer 对象。

特点：
- Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate
- Tagged Pointer指针的值不再是地址了，而是真正的值。
    - 实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。
    - 它的内存并不存储在堆中，也不需要malloc和free。
- 在内存读取上有着3倍的效率，创建时比以前快106倍。

~~~
NSNumber *number1=@1;
NSNumber *number2=@2;
NSNumber *number3=@3;

NSLog(@"number1 pointer is %p", number1);
NSLog(@"number2 pointer is %p", number2);
NSLog(@"number3 pointer is %p", number3);

在64位模拟器中运行后，我得到了如下结果：

number1 pointer is 0xb000000000000012
number2 pointer is 0xb000000000000022
number3 pointer is 0xb000000000000032
~~~

可以看出number1、number2和number3的值前4位都是0xb，后4位都是0x2（指针的Tag），中间就是实际的取值，因此，这些NSNumber已经不需要再分配内存（指堆中内存）了，直接可以把实际的值保存到指针中，而无需再去访问堆中的数据。这无疑提高的内存访问速度和整体运算速度。也就是说Tagged Pointer本身就可以表示一个NSNumber了。

~~~
NSNumber*numberBig=@(0x2233567890ABCDEF);
NSLog(@"numberBig pointer is %p", numberBig);

在64位模拟器中运行后，我得到了如下结果：
代码 objc:
numberBig pointer is 0x1394026a0
~~~

numberBig指针最后4位都是0，应该是分配在堆中的对象。因此，如果NSNumber超出了Tagged Pointer所能表示的范围，系统会自动采用分配成对象，可以根据指针的最后4位是否为0来区分。

总结：
Tagged Pointer通过在其最后一个bit位设置一个特殊标记，用于将数据直接保存在指针本身中。Tagged Pointer并不是真正的对象，使用时需要注意不要直接访问其isa变量。

12、NSTimer循环引用解决方案
timer作为VC的属性，被VC强引用，创建timer对象时VC作为target被timer强引用，即循环引用。

- weak指针：

既然是强引用导致循环引用，那么用__weak修饰self就好了，想法是对的，但是做法是无效的。因为无论是weak还是strong修饰，在NSTimer中都会重新生成一个新的强引用指针指向self，导致循环引用的。

- 类方法：

创建一个继承NSObject的子类TempTarget，并创建开启定时器的方法，并弱引用target
~~~
self.timer = [TempTarget scheduledTimerWithTimeInterval:1 target:self selector:@selector(timerStart:) userInfo:nil repeats:YES];
~~~

VC强引用timer，因为timer的target是TempTarget实例，所以timer强引用TempTarget实例，而TempTarget实例弱引用VC，解除循环引用。

- WeakProxy:

创建一个继承NSProxy的子类WeakProxy，并实现消息转发的相关方法。弱引用target
~~~
self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:[WeakProxy proxyWithTarget:self] selector:@selector(timerStart:) userInfo:nil repeats:YES];
- (void)dealloc {
    [_timer invalidate];
    NSLog(@"VC销毁了");
}
~~~
将timer的target设置为WeakProxy实例，利用消息转发机制实现执行VC中的计时方法，解决循环引用。

- 使用CGD的Timer

- Block:

创建NSTimer的分类NSTimer+UnretainCycle
~~~
+ (NSTimer *)lhScheduledTimerWithTimeInterval:(NSTimeInterval)inerval
                                      repeats:(BOOL)repeats
                                        block:(void(^)(NSTimer *timer))block {
    return [NSTimer scheduledTimerWithTimeInterval:inerval target:self selector:@selector(blcokInvoke:) userInfo:[block copy] repeats:repeats];
}

+ (void)blcokInvoke:(NSTimer *)timer {
    
    void (^block)(NSTimer *timer) = timer.userInfo;
    if (block) {
        block(timer);
    }
}

//VC调用
self.timer = [NSTimer mxScheduledTimerWithTimeInterval:0.5 repeats:YES block:^(NSTimer *timer) {
        NSLog(@"执行了");
    }];
~~~

13、iOS响应者链、事件的传递
响应者对象（Responder Object），顾名思义，指的是有响应和处理事件能力的对象。响应者链就是由一系列的响应者对象构成的一个层次结构。

UIResponder是所有响应对象的基类，在UIResponder类中定义了处理上述各种事件的接口。我们熟悉的UIApplication、 UIViewController、UIWindow和所有继承自UIView的UIKit类都直接或间接的继承自UIResponder，所以它们的实例都是可以构成响应者链的响应者对象

响应者链：

1、响应者链通常是由视图（UIView）构成的；

2、一个视图的下一个响应者是它视图控制器（UIViewController）（如果有的话），然后再转给它的父视图（Super View）；

3、视图控制器（如果有的话）的下一个响应者为其管理的视图的父视图；

4、单例的窗口（UIWindow）的内容视图将指向窗口本身作为它的下一个响应者

5、单例的应用（UIApplication）是一个响应者链的终点，它的下一个响应者指向nil，以结束整个循环。

第一响应者（First responder）指的是当前接受触摸的响应者对象（通常是一个UIView对象），即表示当前该对象正在与用户交互，它是响应者链的开端。整个响应者链和事件分发的使命都是找出第一响应者。

UIWindow对象以消息的形式将事件发送给第一响应者，使其有机会首先处理事件。如果第一响应者没有进行处理，系统就将事件（通过消息）传递给响应者链中的下一个响应者，看看它是否可以进行处理。

iOS系统检测到手指触摸(Touch)操作时会将其打包成一个UIEvent对象，并放入当前活动Application的事件队列，单例的UIApplication会从事件队列中取出触摸事件并传递给单例的UIWindow来处理，UIWindow对象首先会使用hitTest:withEvent:方法寻找此次Touch操作初始点所在的视图(View)，即需要将触摸事件传递给其处理的视图，这个过程称之为hit-test view。

事件的传递：
UIWindow实例对象会首先在它的内容视图上调用hitTest:withEvent:，此方法会在其视图层级结构中的每个视图上调用pointInside:withEvent:（该方法用来判断点击事件发生的位置是否处于当前视图范围内，以确定用户是不是点击了当前视图），如果pointInside:withEvent:返回YES，则继续逐级调用，直到找到touch操作发生的位置，这个视图也就是要找的hit-test view。

hitTest:withEvent:忽略三种情况：
- hidden=YES
- userInteractionEnabled=NO
- alpha<0.01

14、视图控制器的生命周期方法

1、initWithNibName:bundle:
初始化UIViewController，执行关键数据初始化操作，非StoryBoard创建UIViewController都会调用这个方法。
** 注意: 不要在这里做View相关操作，View在loadView方法中才初始化。**

2、initWithCoder:
如果使用StoryBoard进行视图管理，程序不会直接初始化一个UIViewController，StoryBoard会自动初始化或在segue被触发时自动初始化，因此方法initWithNibName:bundle不会被调用，但是initWithCoder会被调用。

3、awakeFromNib
当awakeFromNib方法被调用时，所有视图的outlet和action已经连接，但还没有被确定，这个方法可以算作适合视图控制器的实例化配合一起使用的，因为有些需要根据用户喜好来进行设置的内容，无法存在storyBoard或xib中，所以可以在awakeFromNib方法中被加载进来

4、loadView

当执行到loadView方法时，如果视图控制器是通过nib创建，那么视图控制器已经从nib文件中被解档并创建好了，接下来任务就是对view进行初始化。

loadView方法在UIViewController对象的view被访问且为空的时候调用。这是它与awakeFromNib方法的一个区别。
假设我们在处理内存警告时释放view属性:self.view = nil。因此loadView方法在视图控制器的生命周期内可能被调用多次。
loadView方法不应该直接被调用，而是由系统调用。它会加载或创建一个view并把它赋值给UIViewController的view属性。

在创建view的过程中，首先会根据nibName去找对应的nib文件然后加载。如果nibName为空或找不到对应的nib文件，则会创建一个空视图(这种情况一般是纯代码)

注意:在重写loadView方法的时候，不要调用父类的方法。

5、viewDidLoad
当loadView将view载入内存中，会进一步调用viewDidLoad方法来进行进一步设置。此时，视图层次已经放到内存中，通常，我们对于各种初始化数据的载入，初始设定、修改约束、移除视图等很多操作都可以这个方法中实现。

视图层次(view hierachy):因为每个视图都有自己的子视图，这个视图层次其实也可以理解为一颗树状的数据结构。而树的根节点，也就是根视图(root view),在UIViewController中以view属性。它可以看做是其他所有子视图的容器，也就是根节点。

6、viewWillAppear
系统在载入所有的数据后，将会在屏幕上显示视图，这时会先调用这个方法，通常我们会在这个方法对即将显示的视图做进一步的设置。比如，设置设备不同方向时该如何显示；设置状态栏方向、设置视图显示样式等。

另一方面，当APP有多个视图时，上下级视图切换是也会调用这个方法，如果在调入视图时，需要对数据做更新，就只能在这个方法内实现。

7、viewWillLayoutSubviews
view 即将布局其Subviews。 比如view的bounds改变了(例如:状态栏从不显示到显示,视图方向变化)，要调整Subviews的位置，在调整之前要做的工作可以放在该方法中实现

8、viewDidLayoutSubviews

view已经布局其Subviews，这里可以放置调整完成之后需要做的工作。

9、 viewDidAppear

在view被添加到视图层级中以及多视图，上下级视图切换时调用这个方法，在这里可以对正在显示的视图做进一步的设置。

10、viewWillDisappear

在视图切换时，当前视图在即将被移除、或被覆盖是，会调用该方法，此时还没有调用removeFromSuperview。

11、viewDidDisappear

view已经消失或被覆盖，此时已经调用removeFromSuperView;

12、 dealloc

视图被销毁，此次需要对你在init和viewDidLoad中创建的对象进行释放。

13、didReceiveMemoryWarning

在内存足够的情况下，app的视图通常会一直保存在内存中，但是如果内存不够，一些没有正在显示的viewController就会收到内存不足的警告，然后就会释放自己拥有的视图，以达到释放内存的目的。但是系统只会释放内存，并不会释放对象的所有权，所以通常我们需要在这里将不需要显示在内存中保留的对象释放它的所有权，将其指针置nil。

总结，两种方式:
~~~
 //nib、storyboard文件中加载创建
+[ViewController load]
+[ViewController initialize]
-[ViewController initWithCoder:]
-[ViewController awakeFromNib]
-[ViewController loadView]
-[ViewController viewDidLoad]
-[ViewController viewWillAppear:]
-[ViewController viewWillLayoutSubviews]
-[ViewController viewDidLayoutSubviews]
-[ViewController viewDidAppear:]
-[ViewController viewWillDisappear:]
-[ViewController viewDidDisappear:]
- dealloc

//编码创建
1、alloc、init
2、loadView
3、viewDidLoad
4、ViewWillAppear
5、viewWillLayoutSubviews
6、viewDidLayoutSubviews
7、viewDidAppear
8、viewWillDisappear
9、viewDidDisappear
10、dealloc
~~~

15、常见的信号崩溃

- SIGABRT 6  abort()
- SIGBUS 10  bus error
- SIGFPE 8   floating point exception
- SIGILL 4   illegal instruction (not reset when caught)
- SIGPIPE 13 write on a pipe with no one to read it  
- SIGSEGV 11 segmentation violation
- SIGSYS 12  bad argument to system call
- SIGTRAP 5  trace trap (not reset when caught)

SIGPIPE: 管道另一端没有进程接收数据，导致管道破裂而崩溃。


一、导致SIGSEGV 11
- 试图对仅仅读映射区域进行写操作 。
- 訪问的内存已经被释放，也就是已经不存在或者越界。
 
二、导致SIGBUS 10 信号:      
- 硬件故障，不用说，程序猿最常碰上的肯定不是这样的情形。 
- Linux平台上运行malloc()，假设没有足够的RAM。Linux不是让malloc()失败返回。 而是向当前进程分发SIGBUS信号。
- 某些架构上訪问数据时有对齐的要求，比方仅仅能从4字节边界上读取一个4字节的 数据类型。IA-32架构没有硬性要求对齐，虽然未对齐的訪问减少运行效率。另外一些架构，比方SPARC、m68k，要求对齐訪问，否则向当前进程分发SIGBUS信号。 
- 试图訪问一块无文件内容相应的内存区域，比方超过文件尾的内存区域，或者以前有文件内容相应，如今为还有一进程截断过的内存区域。

三、SIGBUS与SIGSEGV信号的一般差别例如以下: 
    
1、SIGBUS(Bus error)
意味着指针所相应的地址是有效地址，但总线不能正常使用该指针。一般是未对齐的数据訪问所致。 

2、SIGSEGV(Segment fault)意味着指针所相应的地址是无效地址。没有物理内存相应该地址。 

16、webview插入js, 在webView:didCreateJavaScriptContext:forFrame:插入

17、网络模块性能数据，调用系统私有函数_timingData获取所有性能数据
- 请求耗时: 请求结束 - 请求开始
- 服务器响应耗时: 响应开始 - 请求结束
- 下载耗时: 响应结束 - 响应开始
- DNS查询耗时
- SSL握手耗时
- 如果SSL结束时间为零,取其最近的时间指标(TCP建联结束时间),挽救一下
- TCP建联耗时
- 请求数据大小
- 响应数据大小

18、webviewJavascript原理

1、js调用OC: 通过设置iframe.src，发送https请求，从代理方法shouldStartLoadWithRequest中截取数据message，然后从注册的回调字典中获取回调并调用
~~~
WVJBHandler handler = self.messageHandlers[message[@"handlerName"]];
~~~

2、OC调用JS: callHandler->转换为js字符串->使用stringByEvaluatingJavascript方法调用

19、drawRect内存爆增的原因

只要重写drawRect,即使空方法，也会增长许都内存(5M)

20、圆角的实现

UIBezierPath+CAShapeLayer
~~~
/**
 *  设置部分圆角(绝对布局)
 *
 *  @param corners 需要设置为圆角的角 UIRectCornerTopLeft | UIRectCornerTopRight | UIRectCornerBottomLeft | UIRectCornerBottomRight | UIRectCornerAllCorners
 *  @param radii   需要设置的圆角大小 例如 CGSizeMake(20.0f, 20.0f)
 */
- (void)addRoundedCorners:(UIRectCorner)corners
                withRadii:(CGSize)radii {
    
    UIBezierPath* rounded = [UIBezierPath bezierPathWithRoundedRect:self.bounds byRoundingCorners:corners cornerRadii:radii];
    CAShapeLayer* shape = [[CAShapeLayer alloc] init];
    [shape setPath:rounded.CGPath];
    
    self.layer.mask = shape;
}

/**
 *  设置部分圆角(相对布局)
 *
 *  @param corners 需要设置为圆角的角 UIRectCornerTopLeft | UIRectCornerTopRight | UIRectCornerBottomLeft | UIRectCornerBottomRight | UIRectCornerAllCorners
 *  @param radii   需要设置的圆角大小 例如 CGSizeMake(20.0f, 20.0f)
 *  @param rect    需要设置的圆角view的rect
 */
- (void)addRoundedCorners:(UIRectCorner)corners
                withRadii:(CGSize)radii
                 viewRect:(CGRect)rect {
    
    UIBezierPath* rounded = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:radii];
    CAShapeLayer* shape = [[CAShapeLayer alloc] init];
    [shape setPath:rounded.CGPath];
    
    self.layer.mask = shape;
}
~~~

21、FPS

Frames Per Second的简称缩写，意思是每秒传输帧数，可以理解为我们常说的刷新率。FPS是测量用于保存、显示动态视频的信息数量。每秒钟帧数愈多，所显示的画面会愈流畅，fps值越低就越卡顿，所以这个值在一定程度上可以衡量应用在图像绘制渲染处理时的性能。

22、三种定时器
- NSTimer
- CADisplayLink
- GCD

CADisplayLink

优点：依托于设备屏幕刷新频率触发事件，所以其触发时间上是最准确的。也是最适合做UI不断刷新的事件，过度相对流畅，无卡顿感。

缺点：
- 由于依托屏幕刷新频率，如果CPU不堪重负影响力屏幕刷新，那么触发事件也会相应收到影响
- selector事件执行时间如果大于其触发间隔会造成掉帧现象

GCDTimer

优点: 不受当前runloopMode影响

缺点：计时效应仍不是百分之百准确的。另外，他的触发事件也有可能被阻塞，当GCD内部管理的所有线程都被占用时，其触发事件将被延迟。

## 参考
- [iOS字典和数组底层实现原理](https://www.pianshen.com/article/3531450270/)
- [哈希表原理](https://blog.csdn.net/yyyljw/article/details/80903391)
- [iOS标记指针（Tagged Pointer）技术](https://blog.csdn.net/Nathan1987_/article/details/78388581)
- [Objective-C对象的TaggedPointer特性](https://www.jianshu.com/p/dcbf48a733f9)
- [iOS事件响应链(通俗易懂篇)](https://blog.csdn.net/u013602835/article/details/79986819)
- [UIViewController 的生命周期](https://www.jianshu.com/p/d60b388b19f5)
- [iOS中视图控制器的生命周期](https://www.cnblogs.com/gzhu-lkun/p/5967055.html)
- [self与super](https://blog.csdn.net/li15809284891/article/details/54836905)
- [UIView的hitTest和pointInside方法](https://www.jianshu.com/p/c87de31b3985)

