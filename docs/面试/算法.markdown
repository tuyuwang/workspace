---
layout: default
title: 算法
nav_order: 2
parent: 面试
---

在面试中如果遇到难题，有3种办法分析、解决复杂的问题：画图能使抽象问题形象化，举例使抽象问题具体化，分解使抽象问题简单化。

斐波那契数列： 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368........
这个数列从第3项开始，每一项都等于前两项之和。

1、把一个字符串转换成整数
注意：考虑到输入的字符串中有非数字字符和正负号，要考虑到最大的正整数和最小的负整数以及溢出。同时面试官还期待应聘者能够考虑到当输入的字符串不能转换成整数时，应该如何做错误处理

## 常用的数据结构

- 数组、字符串
- 链表
- 栈
- 队列
- 双端队列
- 树


## 数组(Array)
数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。数组可以说是最基本的数据结构，在各种编程语言中都有对应。一个数组可以分解为多个数组元素，按照数据元素的类型，数组可以分为整型数组、字符型数组、浮点型数组、指针数组和结构数组等。数组还可以有一维、二维以及多维等表现形式。 [5] 

优点：
构建一个数组非常简单
能让我们在O(1)的时间里根据数组的下标查询某个元素

缺点：
构建时必须分配一段连续的空间
查询某个元素是否存在时需要遍历整个数组，耗费O(n)的时间（其中，n是元素的个数）
删除和添加某个元素时，同样需要耗费O(n)的时间

## 栈( Stack)
栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。栈按照后进先出的原则来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。栈中没有数据时，称为空栈。 [5] 

特点
后进先出LIFO

算法的基本思想
可以用一个单链表实现
只关心上一次的操作
处理完上一次的操作后，能在O(1)时间内查找到更前一次的操作

## 队列(Queue)
队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。队列中没有元素时，称为空队列。 [5] 

特点
先进先出FIFO

常用的场景
广度优先搜索

## 双端队列

基本实现
可以使用一个双链表
队列的头尾两端能在O(1)的时间内进行数据的查看，添加和删除

常用的场景
实现一个长度动态变化的窗口或者连续区间

## 链表( Linked List)
链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。 [5] 

单链表：链表中的每一个元素实际上是一个单独的对象，而所有对象都通过每个元素中的引用字段链接在一起

双链表：与单链表不同的是，双链表的每个结点中都含有两个引用字段

优点：
灵活地分配内存空间
能在O(1)时间内删除或者添加元素

缺点：
查询元素需要O(n)时间

解题技巧
利用快慢指针（有时候需要用到三个指针）
构建一个虚假的链表头

例如
两个排序链表，进行整合排序
将链表的奇偶数按原定顺序分离，生成前半部分为奇数，后半部分为偶数的链表

如何训练训练该技巧
在纸上或者白板上画出节点之间的相互关系
画出修改的方法



## 树( Tree)
树是典型的非线性结构，它是包括，2个结点的有穷集合K。在树结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个后继结点，m≥0。 [5] 

树的共性：
结构直观
通过树的问题来考察递归算法的掌握熟练程度

面试中常考的树的形状有：
普通二叉树
平衡二叉树
完全二叉树
二叉搜索树
四叉树
多叉树
特殊的树：红黑树、白平衡二叉搜索树


图(Graph)
图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。 [5] 

堆(Heap)
堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。堆的特点是根结点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构。 [5] 

散列表(Hash)
散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。

## LRU算法
LRU缓存淘汰算法是一种常用的策略。LRU的全称是Least Recently Used,也就是说我们认为最近使用过的数据应该是有用的，很久都没用过的数据应该是无用的，内存满了就优先删除那些很久没用过的数据。

LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。借助哈希表赋予了链表快速查找的特性嘛：可以快速查找某个 key 是否存在缓存（链表）中，同时可以快速删除、添加节点

~~~
class Node {
    public var key: Int
    public var val: Int
    public var prev: Node?
    public var next: Node?

    public init(_ key: Int, _ val: Int) {
        self.key = key
        self.val = val
    }
}

class DoubleList {
    // 在链表头部添加节点x,时间O(1)
    public func addFirst(_ x: Node) {}

    // 删除链表中的x节点(x一定存在)
    // 由于是双链表且给的是目标Node节点，时间O(1)
    public func remove(_ x: Node) {}

    // 删除链表中最后一个节点，并返回该节点，时间O(1)
    public func removeLast() -> Node {}

    // 返回链表长度，时间O(1)
    public func size() -> Int {}
}

class LRUCache {
    // key -> Node(key, val)
    private var map: Dictionary<Integer, Node>

    // Node(k1,v1) <-> Node(k2,v2)
    private var cache: DoubleList

    // 最大容量
    private var cap: Int

    public func get(_ key: Int) -> Int {
        if !map.contains(key) {
            return -1
        }

        let val = map[key].val

        // 利用put方法把该数据提前
        put(key, val)

        return val
    }

    public func put(_ key: Int, _ val: Int) {
        // 先把新节点x做出来
        let x = Node(key, val)

        if map.contains(key) {
            // 删除旧的节点，新的插到头部
            cache.remove(map[key])
            cache.addFirst(x)

            // 更新map中对应的数据
            map[key] = x 
        } else {
            if (cap == cache.size()) {
                // 删除链表中最后一个数据
                let last = cache.removeLast()
                map.remove(last.key)
            }

            // 直接添加到头部
            cache.addFirst(x)
            map[key] = x
        }
    }
}
~~~

### 位图法

[位图算法](https://www.cnblogs.com/zhuoqingsen/p/9214709.html)
[位图百科](https://baike.baidu.com/item/%E4%BD%8D%E5%9B%BE%E6%B3%95/9947453?fr=aladdin)

应用:
1、判断一个数是否存在某数据中，假如有40亿数据，我们如何快速判断指定一个数是否存在？

申请512M的内存 512M=512*1024*1024B*8=4294967296比特(bit)  这个空间可以装40亿了
一个bit位代表一个int值
读入40亿个数，设置相应的bit位
读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在


2、判断整形数组是否重复

它的做法是按照集合中最大元素max创建一个长度为max+1的新数组，然后再次扫描原数组，遇到几就给新数组的第几位置上1，如遇到 5就给新数组的第六个元素置1，这样下次再遇到5想置位时发现新数组的第六个元素已经是1了，这说明这次的数据肯定和以前的数据存在着重复。它的运算次数最坏的情况为2N。如果已知数组的最大值即能事先给新数组定长的话效率还能提高一倍。

3、做交集和并集效率极高

举个例子，现有一位图0000101，代表喜欢吃苹果用户

　　　　　　另一位图0000111，代表喜欢吃西瓜用户

统计喜欢吃苹果或西瓜的用户，0000101|0000111=0000111