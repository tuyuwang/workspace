---
layout: default
title: 设计模式
nav_order: 2
parent: 面试
---

![设计模式](../../../images/Interview/设计模式.jpg)

[设计模式七大原则及代码示例](https://www.cnblogs.com/lifegoeson/p/13456895.html)

## 单一职责

一个类或者一个接口，最好只负责一项职责。

## 开闭原则

一个软件实体如类、模版和函数应该对扩展开放，对修改关闭；

## 里氏替换原则

子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法； 
* 子类可以增加自己特有的方法； 
* 当子类的方法重载父类的方法时，方法的形参要比父类方法的输入参数更佳宽松； 
* 当子类的方法实现父类的抽象方法时，方法的返回值要比父类更加严格；

## 依赖倒置原则

 低层模块尽量都要有抽象类或者接口，或者两者都有； 
* 变量的声明类型尽量是抽象类或者接口； 
* 使用继承时遵循里氏替换原则；

## 接口隔离原则

* 一个接口只服务于一个子模块或业务逻辑，服务定制； 
* 通过业务逻辑压缩接口中的public方法，让接口看起来更加精悍； 
* 已经被污染了的接口，尽量修改，如果变更风险太大，则用适配器模式进行转化； 
* 根据具体的业务，深入了解逻辑，用心感知去控制设计思路；

## 迪米特原则

定义：一个对象应该对其他对象保持最少的了解，其核心精神就是：不和陌生人说话，通俗之意就是一个对象对自己需要耦合关联调用的类应该知道的少；这会导致类之间的耦合度降低，每个类都尽量减少对其他类的依赖。


结构化程序设计的主要原则

1、自顶向下

　　程序设计时，应先考虑总体，后考虑细节；先考虑全局目标，后考虑局部目标。不要一开始就过多追求众多的细节，先从最上层总目标开始设计，逐步使问题具体化。

2、逐步求精

　　对复杂问题，应设计一些子目标作为过渡，逐步细化。

3、模块化

　　一个复杂问题，肯定是由若干稍简单的问题构成。模块化是把程序要解决的总目标分解为子目标，再进一步分解为具体的小目标，把每一个小目标称为一个模块。

4、限制使用goto语句

　　结构化程序设计方法的起源来自对GOTO语句的认识和争论。肯定的结论是：在块和进程的非正常出口处往往需要用GOTO语句，使用GOTO语句会使程序执行效率较高；在合成程序目标时，GOTO语句往往是有用的，如返回语句用GOTO。否定的结论是：GOTO语句是有害的，是造成程序混乱的祸根，程序的质量与GOTO语句的数量呈反比，应该在所有高级程序设计语言中取消GOTO语句。取消GOTO语句后，程序易于理解、易于排错、容易维护，容易进行正确性证明。作为争论的结论，1974年Knuth发表了令人信服的总结，并证实了：

GOTO语句确实有害，应当尽量避免；
完全避免使用GOTO语句也并非是个明智的方法，有些地方使用GOTO语句，会使程序流程更清楚、效率更高。
争论的焦点不应放在是否取消GOTO语句上，而应放在用什么样的程序结构上。其中最关键的是，应在以提高程序清晰性为目标的结构化方法中限制使用GOTO语句；
面向对象程序设计的主要原则

1、单一职责原则(Single-Responsibility Principle)　　

　　就一个类而言，应该只专注于做一件事和仅有一个引起它变化的原因。所谓职责，我们可以理解为功能，就是设计的这个类功能应该只有一个，而不是两个或更多。也可以理解为引用变化的原因，当你发现有两个变化会要求我们修改这个类，那么你就要考虑撤分这个类了。因为职责是变化的一个轴线，当需求变化时，该变化会反映类的职责的变化。

　　优点：消除耦合，减小因需求变化引起代码僵化。

2、里氏代换原则(Liskov Substitution Principle)

　　子类型必须能够替换它们的基类型。一个软件实体如果使用的是一个基类，那么当把这个基类替换成继承该基类的子类，程序的行为不会发生任何变化。软件实体察觉不出基类对象和子类对象的区别。

　　优点：可以很容易的实现同一父类下各个子类的互换，而客户端可以毫不察觉。

3、依赖倒置原则(Dependence Inversion Principle)

　　要依赖于抽象，不要依赖于具体，客户端依赖于抽象耦合；抽象不应依赖于细节，细节应依赖于抽象；要针对接口编程，不针对实现编程。

　　优点：使用传统过程化程序设计所创建的依赖关系，策略依赖于细节，这是糟糕的，因为策略受到细节改变的影响。依赖倒置原则使细节和策略都依赖于抽象，抽象的稳定性决定了系统的稳定性。

　　怎样做到依赖倒置？

以抽象方式耦合是依赖倒转原则的关键。抽象耦合关系总要涉及具体类从抽象类继承，并且需要保证在任何引用到基类的地方都可以改换成其子类，因此，里氏代换原则是依赖倒转原则的基础。
在抽象层次上的耦合虽然有灵活性，但也带来了额外的复杂性，如果一个具体类发生变化的可能性非常小，那么抽象耦合能发挥的好处便十分有限，这时可以用具体耦合反而会更好。
　　层次化：所有结构良好的面向对象构架都具有清晰的层次定义，每个层次通过一个定义良好的、受控的接口向外提供一组内聚的服务。

　　依赖于抽象：建议不依赖于具体类，即程序中所有的依赖关系都应该终止于抽象类或者接口。尽量做到：

任何变量都不应该持有一个指向具体类的指针或者引用；
任何类都不应该从具体类派生；
任何方法都不应该覆写它的任何基类中的已经实现的方法；

4、接口隔离原则(Interface Segregation Principle)

　　使用多个专一功能的接口比使用一个的总接口总要好。从一个客户类的角度来讲：一个类对另外一个类的依赖性应当是建立在最小接口上的。过于臃肿的接口是对接口的污染，不应该强迫客户依赖于它们不用的方法。

　　优点：会使一个软件系统功能扩展时，修改的压力不会传到别的对象那里。

　　如何实现接口隔离原则？

利用委托分离接口；
利用多继承分离接口；


5、迪米特原则(Law of Demeter)

　　迪米特法则又叫做最少知识原则(Least Knowledge Principle或简写为LKP)，就是说，一个对象应当对其他对象有尽可能少的了解，对象与对象之间应使用尽可能少的方法来关联，避免千丝万缕的关系。

　　在软件系统中，一个模块设计的好不好的最主要、最重要的标志，就是该模块在多大的程度上将自己的内部数据和其他与实现有关的细节隐藏起来。一个设计好的模块可以将它所有的实现细节隐藏起来，彻底地将提供给外界的API和自己的实现分割开来。这样一来，模块与模块之间就可以仅仅通过彼此的API相互通信，而不理会模块内部的工作细节。这一概念就是“信息的隐藏”，或叫做“封装”，也就是大家熟悉的软件设计的基本教义之一。信息的隐藏非常重要的原因在于，它可以使各个子系统之间脱藕，从而允许它们独立地被开发、优化、使用、阅读以及修改。

　　如何实现迪米特法则？

　　迪米特法则的主要用意是控制信息的过载，在将其运用到系统设计中应注意以下几点：

在类的划分上，应当创建有弱耦合的类，类之间的耦合越弱，就越有利于复用
在类的结构设计上，每一个类都应当尽量降低成员的访问权限。一个类不应当public自己的属性，而应当提供取值和赋值的方法让外界间接访问自己的属性。
在类的设计上，只要有可能，一个类应当设计成不变类
在对其它对象的引用上，一个类对其它对象的引用应该降到最低
对于顶级的类来说，只有两个可能的访问性等级：package-private和public，一个类可以设置成为package-private的，就不应该把它设置成为public的
谨慎使用Serializable：如果一个类实现了Serializable接口的话，客户端就可以将这个类串行后再并行化。假如以后这个类一旦修改，客户端势必也将改动。所以能不用就不用


6、开放－封闭原则(Open-Closed Principle)

　　对扩展开放，对修改关闭。

　　优点：按照OCP原则设计出来的系统，降低了程序各部分之间的耦合性，其适应性、灵活性、稳定性都比较好。当已有软件系统需要增加新的功能时，不需要对作为系统基础的抽象层进行修改，只需要在原有基础上附加新的模块就能实现所需要添加的功能。增加的新模块对原有的模块完全没有影响或影响很小，这样就无须为原有模块进行重新测试。

　　如何实现“开-闭”原则？

在面向对象设计中，不允许更改的是系统的抽象层，而允许扩展的是系统的实现层。
解决问题关键在于抽象化，抽象化是面向对象设计的第一个核心本质。对一个事物抽象化，即封装了事物的本质，看不到任何细节。
在面向对象编程中，通过抽象类及接口，规定了具体类的特征作为抽象层，相对稳定，不需更改，从而满足“对修改关闭”；而从抽象类导出的具体类可以改变系统的行为，从而满足“对扩展开放”。
对实体进行扩展时，不必改动软件的源代码或者二进制代码。

### 优秀程序设计的18大原则

1、避免重复原则(DRY - Don’t repeat yourself)

　　编程的最基本原则是避免重复。在程序代码中总会有很多结构体，如循环、函数、类等等。一旦你重复某个语句或概念，就很容易形成一个抽象体。

2、抽象原则(Abstraction Principle)

　　与DRY原则相关。要记住，程序代码中每一个重要的功能，只能出现在源代码的一个位置。

3、简单原则(Keep It Simple and Stupid)

　　简单是软件设计的目标，简单的代码占用时间少，漏洞少，并且易于修改。

4、避免创建你不要的代码(Avoid Creating a YAGNI (You aren’t going to need it))

　　除非你需要它，否则别创建新功能。

5、尽可能做可运行的最简单的事(Do the simplest thing that could possibly work)

　　尽可能做可运行的最简单的事。在编程中，一定要保持简单原则。作为一名程序员不断的反思“如何在工作中做到简化呢?”这将有助于在设计中保持简单的路径。

6、别让我思考(Don’t make me think)

　　这是Steve Krug一本书的标题，同时也和编程有关。所编写的代码一定要易于读易于理解，这样别人才会欣赏，也能够给你提出合理化的建议。相反，若是繁杂难解的程序，其他人总是会避而远之的。

7、开闭原则(Open/Closed Principle)

　　你所编写的软件实体(类、模块、函数等)最好是开源的，这样别人可以拓展开发。不过，对于你的代码，得限定别人不得修改。换句话说，别人可以基于你的代码进行拓展编写，但却不能修改你的代码。

8、代码维护(Write Code for the Maintainer)

　　一个优秀的代码，应当使本人或是他人在将来都能够对它继续编写或维护。代码维护时，或许本人会比较容易，但对他人却比较麻烦。因此你写的代码要尽可能保证他人能够容易维护。用书中原话说“如果一个维护者不再继续维护你的代码，很可能他就有想杀了你的冲动。”

9、最小惊讶原则(Principle of least astonishment)

　　最小惊讶原则通常是在用户界面方面引用，但同样适用于编写的代码。代码应该尽可能减少让读者惊喜。也就是说，你编写的代码只需按照项目的要求来编写。其他华丽的功能就不必了，以免弄巧成拙。

10、单一责任原则(Single Responsibility Principle)

　　某个代码的功能，应该保证只有单一的明确的执行任务。

11、低耦合原则(Minimize Coupling)

　　代码的任何一个部分应该减少对其他区域代码的依赖关系。尽量不要使用共享参数。低耦合往往是完美结构系统和优秀设计的标志。

12、最大限度凝聚原则(Maximize Cohesion)

　　相似的功能代码应尽量放在一个部分。

13、隐藏实现细节(Hide Implementation Details)

　　隐藏实现细节原则，当其他功能部分发生变化时，能够尽可能降低对其他组件的影响。

14、迪米特法则又叫作最少知识原则(Law of Demeter)

　　该代码只和与其有直接关系的部分连接。(比如：该部分继承的类，包含的对象，参数传递的对象等)。

15、避免过早优化(Avoid Premature Optimization)

　　除非你的代码运行的比你想像中的要慢，否则别去优化。假如你真的想优化，就必须先想好如何用数据证明，它的速度变快了。

　　“过早的优化是一切罪恶的根源”——Donald Knuth

16、代码重用原则(Code Reuse is Good)

　　重用代码能提高代码的可读性，缩短开发时间。

17、关注点分离(Separation of Concerns)

　　不同领域的功能，应该由不同的代码和最小重迭的模块组成。

18、拥抱改变(Embrace Change)

　　这是Kent Beck一本书的标题，同时也被认为是极限编程和敏捷方法的宗旨。


## 23种设计模式

创建型模式：
- 工厂方法模式
- 抽象工厂模式
- 单例模式
- 建造者模式
- 原型模式

结构型模式：
- 适配器模式
- 装饰者模式
- 代理模式
- 外观模式
- 桥接模式
- 组合模式
- 享元模式

行为型模式：
- 策略模式
- 模版方法模式
- 观察者模式
- 迭代器模式
- 责任链模式
- 命令模式
- 备忘录模式
- 状态模式
- 访问者模式
- 中介者模式
- 解释器模式


## 工厂方法模式

[JAVA设计模式之抽象工厂模式](https://blog.csdn.net/jason0539/article/details/44976775)

使用场景：在面向对象编程中，许多类型对象的创造需要一系列的步骤。在这种情况下，新对象的建立就是一个过程，不仅是一个操作。

使用工厂方法模式可以轻松方便的构造对象实例，而不必关心构造对象实例的细节和复杂过程。

工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。

工厂方法模式特点：
- 一个抽象产品类、一个抽象工厂类
- 每个具体工厂类只能创建一个具体产品类的实例

当新增具体产品类时，可以通过新增具体工厂类来创建，这样可以保证对原有的工厂不做改动，对修改关闭，对扩展开放，降低耦合。

但是，当产品种类非常多时，需要抽象出多个抽象产品类，按照工厂方法模式定义，会需要多个对应的抽象工厂类。增加了代码量，此时，应该使用抽象工厂模式。

## 抽象工厂模式

抽象工厂模式特点：
- 多个抽象产品类、一个抽象工厂类
- 每个具体工厂类可以创建多个具体产品类的实例

## 单例模式

单例模式特点：
- 单例类只能有一个实例
- 单例类必须自己创建自己的唯一实例
- 单例类必须给所有其他对象提供这一实例

## 建造者模式

定义：将一个复杂对象的构建过程抽象出来，这样可以通过实现具体的过程构建不同的对象。

角色：
- Builder: 为创建一个产品对象的各个部件指定抽象接口
- ConcreteBuilder: 实现Builder的接口，并提供一个检索产品的接口。
- Director: 构造一个使用Builder接口的对象，指导构建过程。
- Product: 表示被构造的复杂对象。

首先定义产品：
~~~

public class Person {
     private String head;
     private String body;
     private String foot;
 
     public String getHead() {
          return head;
     }
     public void setHead(String head) {
          this.head = head;
     }
     public String getBody() {
          return body;
     }
     public void setBody(String body) {
          this.body = body;
     }
     public String getFoot() {
          return foot;
     }
     public void setFoot(String foot) {
          this.foot = foot;
     }
}
public class Man extends Person {
     public Man(){
          System.out.println(“开始建造男人");
     }
}
public class Woman extends Person {
     public Woman(){
          System.out.println(“开始建造女人");
     }
}
~~~


抽象出构建流程接口:
~~~
public interface PersonBuilder {
     void buildHead();
     void buildBody();
     void buildFoot();
     Person buildPerson();
}
~~~


实现具体的构建流程：
~~~

public class ManBuilder implements PersonBuilder {
     Person person;
     public ManBuilder() {
          person = new Man();
     }
     public void buildbody() {
          person.setBody("建造男人的身体");
     }
     public void buildFoot() {
          person.setFoot("建造男人的脚");
     }
     public void buildHead() {
          person.setHead("建造男人的头");
     }
     public Person buildPerson() {
          return person;
     }
}


public class WomanBuilder implements PersonBuilder {
     Person person;
     public WomanBuilder() {
          person = new Woman();
     }
     public void buildbody() {
          person.setBody(“建造女人的身体");
     }
     public void buildFoot() {
          person.setFoot(“建造女人的脚");
     }
     public void buildHead() {
          person.setHead(“建造女人的头");
     }
     public Person buildPerson() {
          return person;
     }
}
~~~

指导构建流程：
~~~

public class PersonDirector {
     public Person constructPerson(PersonBuilder pb) {
          pb.buildHead();
          pb.buildBody();
          pb.buildFoot();
          return pb.buildPerson();
     }
}
~~~

调用：
~~~
public class Test{
     public static void main(String[] args) {
          PersonDirector pd = new PersonDirector();
          Person womanPerson = pd.constructPerson(new ManBuilder());
          Person manPerson = pd.constructPerson(new WomanBuilder());
     }
}
~~~

## 原型模式

定义：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。

优点：
- 比直接new一个对象在性能上要好的多，尤其是复制大对象时。
- 简化对象的创建

## 适配器模式

定义：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。

角色：
- 目标接口 Target：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口
- 需要适配的类 Adaptee：需要适配的类或适配者类
- 适配器 Adapter：通过包装一个需要适配的对象，把原接口转换成目标接口。

实现方式：
- 类的适配器模式，采用继承实现
- 对象适配器，采用对象组合方式实现

继承实现：Adaptee拥有接口A，目标接口为B，通过继承Adaptee创建Adapter子类，Adapter实现接口B，其内部具体实现为调用父类Adaptee的接口A。

对象适配器：创建Adapter类，该类内部拥有Adaptee的成员变量，并实现目标接口B，在目标接口B内部调用Adaptee的需要适配的接口A。

优点：
- 通过适配器，客户端可以调用同一接口，因而对客户的来说是透明的。这样做更简单、更直接、更紧凑。
- 复用了现存的类，解决了现存类和复用环境要求不一致问题
- 将目标类和适配者类解藕，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码。
- 一个对象适配器可以把多个不同的适配者类适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。

缺点：
- 对于对象适配器来说，更换适配器的实现过程比较复杂。

场景：
- 系统需要使用现有的类，而这些类的接口不符合系统的接口
- 想要建立一个可以重用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。
- 两个类所做的事情相同或相似，但是具有不同接口的时候。
- 旧的系统开发的类已实现了一些功能，但是客户端却只能以另外接口的形式访问，但我们不希望手动更改原有类的时候。
- 使用第三方组件，组件接口定义和自己定义的不同，不希望修改自己的接口，但是要使用第三方组件接口的功能。


## 装饰者模式

[设计模式之装饰者模式](https://www.cnblogs.com/of-fanruice/p/11565679.html)

定义：动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

抽象接口方法A， Component类实现接口A，Decorator类持有Component类的对象，并实现接口A，内部调用Component对象的A方法，并添加其他功能。

特点：Component原有的方法内部实现保持不变，通过Decorator扩展其他功能。

优点：
- 装饰类和被装饰类可以独立发展，而不会相互耦合。换句话说，Component类无需知道Decorator类，Decorator类是从外部来扩展Component类的功能，而Decorator也不用知道具体的构件。
- 装饰模式是继承关系的一个替代方案。我们看装饰类Decorator,不管装饰多少层，返回的对象还是Component，实现还是is-a的关系
- 装饰者可以动态地扩展一个实现类的功能。

缺点：
- 多层的装饰是比较复杂的

使用场景：
- 需要扩展一个类的功能，或给一个类增加附加功能
- 需要动态地给一个对象增加功能，这些功能可以再动态撤销
- 需要为一批的兄弟类进行改装或加装功能

## 代理模式

定义：为其他对象提供一种代理以控制对这个对象的访问。

代理模式也叫做委托模式，它是一项基本设计技巧。许多其他的模式，如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了委托模式，而且在日常应用中，代理模式可以提供非常好的访问控制。

代理类和主体类实现同样的接口，代理类持有实体类的引用，并接受客户端对代理类中实体引用的外部注入，并代理实体类的功能。

角色定义：
- Subject抽象主题角色：可以是抽象类也可以是接口
- RealSubject: 具体主题角色，被代理角色。是业务逻辑的执行者
- Proxy代理主题角色：委托类，代理类。负责对真实角色的应用，把所有抽象主题类定义的方法限制 委托给真实主题角色实现，并且在真实主题角色处理完毕前后做预处理和善后处理工作。

优点：
- 职责清晰：真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事物，通过后期的代理完成一件🍜，附带的结果就是编程简洁清晰。
- 高扩展性：具体主题角色是随时都会发生变化的，只要实现了接口，代理类完全就可以在不做任何修改的情况下使用。

## 门面模式

定义：外观模式，要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。

门面模式注重统一的对象，也就是提供一个访问子系统的接口，除了这个接口不允许有任何访问子系统的行为发生。

角色定义：
- Facade门面角色：客户端可以调用这个角色的方法。此角色知晓子系统的所有功能和责任。一般情况下， 本角色会将所有从客户端发来的请求委派到相应的子系统去，也就说该角色没有实际的业务 逻辑，只是一个委托类。
- subsystem子系统角色：可以同时有一个或者多个子系统。每一个子系统都不是一个单独的类，而是一个类的集
合。子系统并不知道门面的存在。对于子系统而言，门面仅仅是另外一个客户端而已。

优点：
- 减少系统的相互依赖
- 提高了灵活性
- 提高安全性

缺点：
- 不符合开闭原则：一旦在系统投产后发现有一个小错误，你怎么解决?完全遵从 开闭原则，根本没办法解决。继承?覆写?都顶不上用，唯一能做的一件事就是修改门面角 色的代码，这个风险相当大

使用场景：
- 为一个复杂的模块或子系统提供一个供外界访问的接口
- 子系统相互独立，外界对子系统的访问只需要黑箱操作
- 预防低水平人员带来的风险扩散：比如一个低水平的技术人员参与项目开发，为降低个人代码质量对整体项目的影响风 险，一般的做法是“画地为牢”，只能在指定的子系统中开发，然后再提供门面接口进行访问 操作。

注意事项：
- 一个子系统可以有多个门面
- - 门面已经庞大到不能忍受的程度
- - 子系统可以提供不同的访问路径：增加的门面非常简单，委托给了已经存在的门面对象Facade进行处理，为什么要使用委托而不再编写一个委托到子系统的方法呢?那是因为在面向对象的编程中，尽量保持相同的 代码只编写一遍，避免以后到处修改相似代码的悲剧。
- 门面不参与子系统内的业务逻辑：否则就会产生一个倒依赖的问题:子系统必须依赖门面才能被访问，这是设计上一个严重错 误，不仅违反了单一职责原则，同时也破坏了系统的封装性。


## 桥梁模式

定义：将抽象与实现解耦，使得两者可以独立变化。

桥梁模式的重点是“解耦”上，如何让它们两者解耦是需要了解的重点。

角色：
- Abstraction: 抽象化角色，定义该角色的行为，同时保存一个对实现化角色的引用，该角色一般是抽象类。
- Implementor: 实现化角色，是接口或者抽象类，定义角色必须的行为和属性
- RefinedAbstraction: 修正抽象化角色，它引用实现化角色对抽象化角色进行修正
- ConcreteImplementor: 具体实现化角色，实现接口或抽象类定义的方法和属性

抽象角色引用实现角色，或者说抽象角色的部分实现是由实现角色完成的。

比如，毛笔与颜色、蜡笔和颜色，毛笔是抽象化角色，定义写字行为，内部引用颜色的抽象类实例。颜色为实现化角色，是个抽象类，其具体类定义具体颜色。具体毛笔类修正写字行为，引用颜色具体类进行功能实现。

优点：
- 抽象和实现分离：主要特点，完全是为了解决基继承的缺点而提出的设计模式。在该模式下，实现可以不受抽象的约束，不用再绑定在一个固定的抽象层次上。
- 优秀的扩充能力，在两个变化纬度中任意扩展一个维度，都不需要修改原有系统
- 实现细节对客户透明

使用场景：
- 不希望或不使用继承的场景
- 接口或抽象类不稳定的场景
- 重用性要求较高的场景

注意事项：
桥梁模式是非常简单的，使用该模式时主要考虑如何拆分抽象和实现，并不是一涉及继 承就要考虑使用该模式，那还要继承干什么呢?桥梁模式的意图还是对变化的封装，尽量把 可能变化的因素封装到最细、最小的逻辑单元中，避免风险扩散。因此读者在进行系统设计 时，发现类的继承有N层时，可以考虑使用桥梁模式。

## 组合模式

定义：将对象组合树形结构以表示部分-整体的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性

角色：
- Component抽象构件角色：定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性
- Leaf叶子构件：叶子对象，其下再也没有其他的分支，也就是遍历的最小单元
- Composite树枝构件：树枝对象，作用是组合树枝节点和叶子节点形成一个树形结构

抽象构件定义公有的方法，比如连锁理发店会员刷卡记分行为。树枝构件，如总店、树枝分店，内部维护一个子店数组，并实现记分方法，遍历调用数组内部子店的记分方法。叶子构件，如叶子分店，没有子店，实现自身记分方法。

优点：
- 高层模块调用简单：一棵树形机构中的所有节点都是Component，局部和整体对调用者来说没有任何区别，也就是说，高层模块不必关心自己处理的是单个对象还是整个组合结构，简化了高层模块的代码。
- 节点自由增加：使用了组合模式后，只要找到父节点就可以很方便的添加子节点，符合开闭原则。

缺点：
- 与依赖倒置原则冲突，树枝与树叶是具体对象，限制了接口影响范围。

使用场景：
- 维护和展示部分-整体关系的场景，如树形菜单、文件和文件夹管理
- 从一个整体中能够独立出部分模块或功能的场景

注意事项：
- 只要是树形结构，就要考虑使用组合模式，只要体现局部和整体的关系的时候，考虑组合模式

## 享元模式

定义：使用共享对象可有效地支持大量的细粒度的对象

要求：
- 共享对象
- 细粒度对象

要求细粒度对象，那么不可避免地使得对象数量多且性质相近，那我们就将这些对象信息分为两个部分：内部状态与外部状态。

- 内部状态：是对象可共享出来的信息，存储在享元对象内部并且不会随环境的改变而改变。
- 外部状态：是对象得以依赖的一个标记，是随环境改变而改变的、不可以共享的状态，唯一索引值

角色：
- Flyweight: 抽象享元角色，简单地说是一个产品抽象类，同时定义出对象的外部状态和内部状态的接口或实现
- ConcreteFlyweight：具体享元角色，一个产品类，实现抽象角色定义的业务。该角色中需要注意的是内部状态处理应 该与环境无关，不应该出现一个操作改变了内部状态，同时修改了外部状态，这是绝对不允 许的。
- unsharedConcreteFlyweight：不可共享的享元角色，不存在外部状态或者安全要求(如线程安全)不能够使用共享技术的对象，该对象一般不会出现在享元工厂中。
- FlyweightFactory：享元工厂，职责非常简单，就是构造一个池容器，同时提供从池中获得对象的方法。

享元模式的目的在于运用共享技术，使得一些细粒度的对象可以共享，我们的设计确实 也应该这样，多使用细粒度的对象，便于重用或重构。

在iOS中UITableViewCell和UICollectionCell都重用池使用都是用到了享元模式

优点：
- 大大减少应用程序创建的对象
- 降低程序内存的占用
- 增强程序的性能

缺点：
- 提高了系统复杂性

需要分离出外部状态和内部状态，而且外部状态具有固化特性，不应该随内部状态改变而改变，否则导致系统的逻辑混 乱。

在iOS中外部状态可以指cell获取的数据源部分，对于cell来说，数据源是固化不可变的部分。

使用场景：
- 系统中存在大量的相似对象
- 细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定的身份
- 需要缓冲池的场景

注意事项：
- 线程安全问题，共用了多个对象，多线程场景下，存在线程安全问题

## 策略模式

定义：定义一组算法，将每个算法都封装起来，并且使它们之间可以互换

角色：
- Context封装角色：上下文角色，起承上启下封装作用，屏蔽高层模块对策略，算法的直接访问，封装可能存在的变化。
- Strategy抽象策略角色：策略、算法家族的抽象，通常为接口，定义每次策略或算法必须具有的方法和属性。
- ConcreteStategy：具体策略角色，实现抽象角色中的操作，该类含有具体的算法

Strategy抽象类定义接口A，ConcreteStategy具体实现类实现策略接口A，用Context进行封装，持有抽象类的具体对象，并实现抽象接口A，在接口内部调用具体对象的A方法。

优点：
- 算法可以自由切换：这是策略模式本身定义的，只要实现抽象策略，它就成为策略家族的一个成员，通过封装角色对其进行封装，保证对外提供可自由切换的策略
- 避免使用多重条件判断：由其他模块决定采用何种策略，策略家族对外提供的访问接口就是封装类，简化了操作，同时避免了条件语句判断。
- 扩展性良好：在现有的系统中增加一个策略太容易 了，只要实现接口就可以了，其他都不用修改，类似于一个可反复拆卸的插件，这大大地符 合了OCP原则。

缺点：
- 策略类数量增多
- 所有的策略类都需要对外暴露：上层模块必须知道有哪些策略，然后才能决定使用哪一个策略，这与迪米特法则是相违 背的，我只是想使用了一个策略，我凭什么就要了解这个策略呢?那要你的封装类还有什么意义?这是原装策略模式的一个缺点

使用场景：
- 多个类只有在算法或行为上稍有不同的场景
- 算法需要自由切换的场景
- 需要屏蔽算法规则的场景

注意事项：
- 如果系统中的一个策略家族的具体策略数量超过4个，则需要考虑使用混合模式，解决 策略类膨胀和对外暴露的问题，否则日后的系统维护就会成为一个烫手山芋，谁都不想接。

## 模版方法模式

定义：定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤

角色：
- 抽象模版：AbstractClass
- - 基本方法，是由子类实现的方法，并且在模板方法被调用。
- - 模版方法，实现对基本方法的调度， 完成固定的逻辑。
- - 钩子方法，通过钩子方法，改变执行基本方法的时机
- 具体模版：ConcreteClass，实现父类定义的一个或多个抽象方法，即父类的基本方法在子类得以实现

抽象类定义好通过模版方法定义好执行基本方法的通用逻辑，并通过钩子方法进行基本方法调用的时机判断。由具体子类覆写钩子方法，实现基本方法。

优点：
- 封装不变部分，扩展可变部分
- 提取公共部分代码，便于维护
- 行为由父类控制，子类实现：基本方法是由子类实现的，因此子类可以通过扩展的方式增加相应的功能，符合闭原则。

缺点：
- 子类对父类的结果产生影响，复杂的项目中，会带来代码阅读的难度，而且也会让新手产生不适感。

使用场景：
- 多个子类有公有的方法，并且逻辑基本相同时
- 重要、复杂的算法，可以把核心算法设计为模版方法，周边的相关细节功能则由各个
子类实现。
- 重构时，模版方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通 过钩子函数(见“模板方法模式的扩展”)约束其行为

## 观察者模式

定义：发布订阅模式，定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。

角色：
- Subject被观察者：定义被观察者必须实现的职责，它必须能够动态地增加，取消观察者。一般是抽象类或实现类，仅仅完成作为被观察者必须实现的职责：管理观察者并通知观察者
- Observer观察者：观察者收到消息后，即进行update更新操作，对接受的数据进行处理
- ConcreteSubject具体的被观察者：定义被观察者自己的业务逻辑，同时定义对哪些事件进行通知。
- ConcreteObserver具体的观察者：每个观察在接收到消息后的处理反应是不同，各个观察者有自己的处理逻辑

优点：
- 观察者和被观察者之间是抽象耦合，不管是增加观察者还是被观察者都非常容易扩展
- 建立一套触发机制：根据单一职责原则，每个类的职责是单一的，那么怎么把各个单一的职责串联成真实世界的复杂的逻辑关系呢?比如，我们去打猎，打死了一只母鹿，母鹿有三个幼崽，因失去了母鹿而饿死，尸体又被两只秃鹰争抢，因分配不均，秃鹰开始斗殴，然后羸弱的秃鹰死掉，生存下来的秃鹰，则因此扩大了地盘......这就是一个触发机制，形成了一个触发链。观察者 模式可以完美地实现这里的链条形式。

缺点：
- 开发效率：多个观察者，开发和调试比较复杂
- 运行效率：通知是顺序执行，一个执行卡壳，影响后续执行

使用场景：
- 关联行为场景。关联行为是可拆分的，而不是组合关系
- 事件多级触发场景
- 跨系统的消息交换场景，如消息队列的处理机制。

注意事项：
- 广播链的问题：链一旦建立，这个逻辑就比较复杂，可维护性非常差，根据经验建议，在一个观察者模式中最多出现一个对象既是观察者也是被观察者，也就是说消息最多转发一次(传递两次)，这 还是比较好控制的。
- 异步处理问题

## 迭代器模式

定义：它提供一种方法访问一个容器对象中各个元素，而不是暴露该对象的内部细节。

迭代器模式就是为了解决遍历容器中的元素而诞生的。

迭代器模式提供了遍历容器的方便性，容器只需要管理增减元素接可以了，需要遍历时交给爹大气进行。

角色：
- Iterator抽象迭代器：定义访问和遍历元素的接口，而且基本上是固定三个方法：first()\next(),hasNext()
- ConcreteIterator具体迭代器：实现迭代器接口，完成容器元素的遍历
- Aggregate抽象容器：负责提供创建具体迭代器角色的接口，必然提供一个类袭createIterator()这样的方法。
- Concrete Aggregate 具体容器：实现容器接口定义的方法，创建出容器迭代对象。

容器内实现添加，删除方法，遍历由迭代器完成，迭代器内部持有容器对象，并持有索引变量，通过索引进行遍历。

## 责任链模式

定义：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连城一条链，并沿着这条链传递该请求。

角色：
- Handler:抽象处理者，定义handleMessage,唯一对外开放的方法，定义一个链的编排方法setNext，设置下一个处理者，三是定义了具体请求必须实现的两个方法：自己能够处理的级别getHanlerLevel和具体的处理任务echo
- ConcreteHandler: 具体处理者，实现抽象处理者的接口

类似于单链表结构，一个请求经过每一个节点，每个节点记录下个处理者节点，依次进行请求的处理操作。

优点：
- 请求和处理分开：请求者可以不用知道是谁处理的，处 理者可以不用知道请求的全貌
- 两者解耦，提高系统的灵活性。

缺点：
- 性能问题：每个请求都是从链头遍历到链尾，特别 是在链比较长的时候，性能是一个非常大的问题
- 调试问题：特别是链条比较长，环节比较多的时候，由于采用了类似递归的方式，调试的时候逻辑可能比较复杂。

注意事项：
- 链中节点数量需要控制，避免出现超长链的情况，一般的做法是在Handler中设置一个最大节点数量，在setNext方法中判断是否已经是超过其阈值，超过则不允许该链建立，避免 无意识地破坏系统性能。

## 命令模式

定义：将一个请求封装成一个对象，从而使你用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。

角色：
- Receive接收者角色：命令的执行者
- Command命令角色：需要执行的所有命令都在这里声明
- Invoker调用者角色：接收到命令，并执行命令

Receive定义业务接口A，具体的Receive进行各自实现接口A，Command抽象类定义执行命令的接口execute(),具体Command的内部引用receive具体对象，并实现execute方法，在该方法内部调用receive对象的接口A方法。调用者Invoker引用Command具体对象，并实现命令的调用。

优点：
- 类间解耦：调用者与接收者角色之间没有任何依赖关系，调用者实现功能时只需要调用抽象类Command的execute方法就可以。
- 可扩展性：Command的子类可以非常容易地扩展，而调用者Invoker和高层次的模块Client不产生严 重的代码耦合。
- 命令模式结合其他模式会更优秀：命令模式可以结合责任链模式，实现命令族解析任务;结合模板方法模式，则可以减少Command子类的膨胀问题。

缺点：如果有N个命令，就有N个命令子类

使用场景：

